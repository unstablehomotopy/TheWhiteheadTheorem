\documentclass{book}
\usepackage{fontspec}
\setmainfont{STIX Two Text}

%PACKAGES
\iffalse
Here are the packages that I use
\fi

\usepackage{blindtext, hyperref, verbatim, minted, graphicx, amssymb, textcomp, enumerate, tcolorbox, newunicodechar, textgreek, wasysym, tipa, eso-pic, lipsum, bbold, dsfont}
\usepackage[margin=1.3in]{geometry}
\usepackage{longtable}
\usepackage{newunicodechar}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{tikz-cd}




%ENVIRONMENTS

%Here I define some common environments. I use definitions, theorems, examples, and lemmas.


\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}


\newunicodechar{â‚™}{${}_{n}$}

\newunicodechar{ğ““}{$\mathcal{D}$}
\newunicodechar{âˆ‚}{$\partial$}
\newunicodechar{âˆ‡}{\raisebox{-0.05cm}{$\nabla$}}

%\newunicodechar{Î âƒ—}{$\stackrel{\arr}{\pi}$}

\newunicodechar{Ã—}{$\times$}
\newunicodechar{â†’}{$\rightarrow$}
\newunicodechar{âŸ¨}{$\langle$}
\newunicodechar{âŸ©}{$\rangle$}
\newunicodechar{â†¦}{$\mapsto$}
\newunicodechar{âˆ§}{$\wedge$}
\newunicodechar{âˆ¨}{$\vee$}
\newunicodechar{âˆƒ}{$\exists$}
\newunicodechar{âˆ€}{$\forall$}
\newunicodechar{Â¬}{$\neg$}
\newunicodechar{áµƒ}{${}^{\texttt{a}}$}
\newunicodechar{áµ‡}{${}^{\texttt{b}}$}
\newunicodechar{á¶œ}{${}^{\texttt{c}}$}
\newunicodechar{áµˆ}{${}^{\texttt{d}}$}
\newunicodechar{áµ‰}{${}^{\texttt{e}}$}
\newunicodechar{á¶ }{${}^{\texttt{f}}$}
\newunicodechar{áµ}{${}^{\texttt{g}}$}
\newunicodechar{Ê°}{${}^{\texttt{h}}$}
\newunicodechar{â±}{${}^{\texttt{i}}$}
\newunicodechar{Ê²}{${}^{\texttt{j}}$}
\newunicodechar{áµ}{${}^{\texttt{k}}$}
\newunicodechar{Ë¡}{${}^{\texttt{l}}$}
\newunicodechar{áµ}{${}^{\texttt{m}}$}
\newunicodechar{â¿}{${}^{\texttt{n}}$}
\newunicodechar{áµ’}{${}^{\texttt{o}}$}
\newunicodechar{áµ–}{${}^{\texttt{p}}$}
\newunicodechar{Ê³}{${}^{\texttt{r}}$}
\newunicodechar{Ë¢}{${}^{\texttt{s}}$}
\newunicodechar{áµ—}{${}^{\texttt{t}}$}
\newunicodechar{áµ˜}{${}^{\texttt{u}}$}
\newunicodechar{áµ›}{${}^{\texttt{v}}$}
\newunicodechar{Ê·}{${}^{\texttt{w}}$}
\newunicodechar{Ë£}{${}^{\texttt{x}}$}
\newunicodechar{Ê¸}{${}^{\texttt{y}}$}
\newunicodechar{á¶»}{${}^{\texttt{z}}$}
\newunicodechar{â°}{${}^{\texttt{0}}$}
\newunicodechar{Â¹}{${}^{\texttt{1}}$}
\newunicodechar{Â²}{${}^{\texttt{2}}$}
\newunicodechar{Â³}{${}^{\texttt{3}}$}
\newunicodechar{â´}{${}^{\texttt{4}}$}
\newunicodechar{âµ}{${}^{\texttt{5}}$}
\newunicodechar{â¶}{${}^{\texttt{6}}$}
\newunicodechar{â·}{${}^{\texttt{7}}$}
\newunicodechar{â¸}{${}^{\texttt{8}}$}
\newunicodechar{â¹}{${}^{\texttt{9}}$}
\newunicodechar{â»}{${}^{\texttt{-}}$}
\newunicodechar{áµ’}{${}^{\texttt{o}}$}
\newunicodechar{áµ–}{${}^{\texttt{Ï‰}}$}
\newunicodechar{â»}{${}^{\texttt{-}}$}
\newunicodechar{Â¹}{${}^{\texttt{1}}$}
\newunicodechar{â‚€}{${}_{\texttt{0}}$}
\newunicodechar{â‚}{${}_{\texttt{1}}$}
\newunicodechar{â‚‚}{${}_{\texttt{2}}$}
\newunicodechar{â‚ƒ}{${}_{\texttt{3}}$}
\newunicodechar{â‚„}{${}_{\texttt{4}}$}
\newunicodechar{â‚…}{${}_{\texttt{5}}$}
\newunicodechar{â‚†}{${}_{\texttt{6}}$}
\newunicodechar{â‚‡}{${}_{\texttt{7}}$}
\newunicodechar{â‚ˆ}{${}_{\texttt{8}}$}
\newunicodechar{â‚‰}{${}_{\texttt{9}}$}
\newunicodechar{ğ”¸}{$\mathbb{A}$}
\newunicodechar{ğ”¹}{$\mathbb{B}$}
\newunicodechar{â„‚}{$\mathbb{C}$}
\newunicodechar{ğ”»}{$\mathbb{D}$}
\newunicodechar{ğ”¼}{$\mathbb{E}$}
\newunicodechar{ğ”½}{$\mathbb{F}$}
\newunicodechar{ğ”¾}{$\mathbb{G}$}
\newunicodechar{â„}{$\mathbb{H}$}
\newunicodechar{ğ•€}{$\mathbb{I}$}
\newunicodechar{ğ•}{$\mathbb{J}$}
\newunicodechar{ğ•‚}{$\mathbb{K}$}
\newunicodechar{ğ•ƒ}{$\mathbb{L}$}
\newunicodechar{ğ•„}{$\mathbb{M}$}
\newunicodechar{â„•}{$\mathbb{N}$} 
\newunicodechar{ğ•†}{$\mathbb{O}$}
\newunicodechar{â„™}{$\mathbb{P}$}
\newunicodechar{â„š}{$\mathbb{Q}$}
\newunicodechar{â„}{$\mathbb{R}$}
\newunicodechar{ğ•Š}{$\mathbb{S}$}
\newunicodechar{ğ•‹}{$\mathbb{T}$} 
\newunicodechar{ğ•Œ}{$\mathbb{U}$}
\newunicodechar{ğ•}{$\mathbb{V}$}
\newunicodechar{ğ•}{$\mathbb{W}$}
\newunicodechar{ğ•}{$\mathbb{X}$}
\newunicodechar{ğ•}{$\mathbb{Y}$}
\newunicodechar{â„¤}{$\mathbb{Z}$}
\newunicodechar{ğ•’}{$\mathbb{a}$}
\newunicodechar{ğ•“}{$\mathbb{b}$}
\newunicodechar{ğ•”}{$\mathbb{c}$}
\newunicodechar{ğ••}{$\mathbb{d}$}
\newunicodechar{ğ•–}{$\mathbb{e}$}
\newunicodechar{ğ•—}{$\mathbb{f}$}
\newunicodechar{ğ•˜}{$\mathbb{g}$}
\newunicodechar{ğ•™}{$\mathbb{h}$}
\newunicodechar{ğ•š}{$\mathbb{i}$}
\newunicodechar{ğ•›}{$\mathbb{j}$}
\newunicodechar{ğ•œ}{$\mathbb{k}$}%ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«
\newunicodechar{ğ•}{$\mathbb{l}$} 
\newunicodechar{ğ•}{$\mathbb{m}$}
\newunicodechar{ğ•Ÿ}{$\mathbb{n}$}
\newunicodechar{ğ• }{$\mathbb{o}$}
\newunicodechar{ğ•¡}{$\mathbb{p}$}
\newunicodechar{ğ•¢}{$\mathbb{q}$}
\newunicodechar{ğ•£}{$\mathbb{r}$}
\newunicodechar{ğ•¤}{$\mathbb{s}$}
\newunicodechar{ğ•¥}{$\mathbb{t}$}
\newunicodechar{ğ•¦}{$\mathbb{u}$}
\newunicodechar{ğ•§}{$\mathbb{v}$}
\newunicodechar{ğ•¨}{$\mathbb{w}$}
\newunicodechar{ğ•©}{$\mathbb{x}$}
\newunicodechar{ğ•ª}{$\mathbb{y}$}
\newunicodechar{ğ•«}{$\mathbb{z}$}
\newunicodechar{ğš«}{$\Delta$}
\newunicodechar{Êƒ}{$\int$}
\newunicodechar{âˆª}{$\cup$}
\newunicodechar{âˆ©}{$\cap$}
\newunicodechar{Â±}{$\pm$}
\newunicodechar{ğ”„}{$\mathfrak{A}$}




\newunicodechar{ğ”…}{$\mathfrak{B}$}
\newunicodechar{â„­}{$\mathfrak{C}$}
\newunicodechar{ğ”‡}{$\mathfrak{D}$}
\newunicodechar{ğ”ˆ}{$\mathfrak{E}$}
\newunicodechar{ğ”‰}{$\mathfrak{F}$}
\newunicodechar{ğ”Š}{$\mathfrak{G}$}
\newunicodechar{â„Œ}{$\mathfrak{H}$}
\newunicodechar{â„‘}{$\mathfrak{I}$}
\newunicodechar{ğ”}{$\mathfrak{J}$}
\newunicodechar{ğ”}{$\mathfrak{K}$}
\newunicodechar{ğ”}{$\mathfrak{L}$}
\newunicodechar{ğ”}{$\mathfrak{M}$}
\newunicodechar{ğ”‘}{$\mathfrak{N}$}
\newunicodechar{ğ”’}{$\mathfrak{O}$}
\newunicodechar{ğ”“}{$\mathfrak{P}$}
\newunicodechar{ğ””}{$\mathfrak{Q}$}
\newunicodechar{â„œ}{$\mathfrak{R}$}
\newunicodechar{ğ”–}{$\mathfrak{S}$}
\newunicodechar{ğ”—}{$\mathfrak{T}$}
\newunicodechar{ğ”˜}{$\mathfrak{U}$}
\newunicodechar{ğ”™}{$\mathfrak{V}$}
\newunicodechar{ğ”š}{$\mathfrak{W}$}
\newunicodechar{ğ”›}{$\mathfrak{X}$}
\newunicodechar{ğ”œ}{$\mathfrak{Y}$}
\newunicodechar{â„¨}{$\mathfrak{Z}$}

\newunicodechar{ğ”}{$\mathfrak{a}$}
\newunicodechar{ğ”Ÿ}{$\mathfrak b$}
\newunicodechar{ğ” }{$\mathfrak{c}$}
\newunicodechar{ğ”¡}{$\mathfrak{d}$}
\newunicodechar{ğ”¢}{$\mathfrak{e}$}
\newunicodechar{ğ”£}{$\mathfrak{f}$}
\newunicodechar{ğ”¤}{$\mathfrak{g}$}
\newunicodechar{ğ”¥}{$\mathfrak{h}$}
\newunicodechar{ğ”¦}{$\mathfrak{i}$}
\newunicodechar{ğ”§}{$\mathfrak{j}$}
\newunicodechar{ğ”¨}{$\mathfrak{k}$}
\newunicodechar{ğ”©}{$\mathfrak{l}$}
\newunicodechar{ğ”ª}{$\mathfrak{m}$}
\newunicodechar{ğ”«}{$\mathfrak{n}$}
\newunicodechar{ğ”¬}{$\mathfrak{o}$}
\newunicodechar{ğ”­}{$\mathfrak{Ï‰}$}
\newunicodechar{ğ”®}{$\mathfrak{q}$}
\newunicodechar{ğ”¯}{$\mathfrak{r}$}
\newunicodechar{ğ”°}{$\mathfrak{s}$}
\newunicodechar{ğ”±}{$\mathfrak{t}$}
\newunicodechar{ğ”²}{$\mathfrak{u}$}
\newunicodechar{ğ”³}{$\mathfrak{v}$}
\newunicodechar{ğ”´}{$\mathfrak{w}$}
\newunicodechar{ğ”µ}{$\mathfrak{x}$}
\newunicodechar{ğ”¶}{$\mathfrak{y}$}
\newunicodechar{ğ”·}{$\mathfrak{z}$}

\newunicodechar{ğ€}{${\bf{A}}$}
\newunicodechar{ğ}{${\bf{B}}$}
\newunicodechar{ğ‚}{${\bf{C}}$}
\newunicodechar{ğƒ}{${\bf{D}}$}
\newunicodechar{ğ„}{${\bf{E}}$}
\newunicodechar{ğ…}{${\bf{F}}$}
\newunicodechar{ğ†}{${\bf{G}}$}
\newunicodechar{ğ‡}{${\bf{H}}$}
\newunicodechar{ğˆ}{${\bf{I}}$}
\newunicodechar{ğ‰}{${\bf{J}}$}
\newunicodechar{ğŠ}{${\bf{K}}$}
\newunicodechar{ğ‹}{${\bf{L}}$}
\newunicodechar{ğŒ}{${\bf{M}}$}
\newunicodechar{ğ}{${\bf{N}}$}
\newunicodechar{ğ}{${\bf{O}}$}
\newunicodechar{ğ}{${\bf{P}}$}
\newunicodechar{ğ}{${\bf{Q}}$}
\newunicodechar{ğ‘}{${\bf{R}}$}
\newunicodechar{ğ’}{${\bf{S}}$}
\newunicodechar{ğ“}{${\bf{T}}$}
\newunicodechar{ğ”}{${\bf{U}}$}
\newunicodechar{ğ•}{${\bf{V}}$}
\newunicodechar{ğ–}{${\bf{W}}$}
\newunicodechar{ğ—}{${\bf{X}}$}
\newunicodechar{ğ˜}{${\bf{Y}}$}
\newunicodechar{ğ™}{${\bf{Z}}$}

\newunicodechar{ğš}{${\bf{a}}$}
\newunicodechar{ğ›}{${\bf{b}}$}
\newunicodechar{ğœ}{${\bf{c}}$}
\newunicodechar{ğ}{${\bf{d}}$}
\newunicodechar{ğ}{${\bf{e}}$}
\newunicodechar{ğŸ}{${\bf{f}}$}
\newunicodechar{ğ }{${\bf{g}}$}
\newunicodechar{ğ¡}{${\bf{h}}$}
\newunicodechar{ğ¢}{${\bf{i}}$}
\newunicodechar{ğ£}{${\bf{j}}$}
\newunicodechar{ğ¤}{${\bf{k}}$}
\newunicodechar{ğ¥}{${\bf{l}}$}
\newunicodechar{ğ¦}{${\bf{m}}$}
\newunicodechar{ğ§}{${\bf{n}}$}
\newunicodechar{ğ¨}{${\bf{o}}$}
\newunicodechar{ğ©}{${\bf{Ï‰}}$}
\newunicodechar{ğª}{${\bf{q}}$}
\newunicodechar{ğ«}{${\bf{r}}$}
\newunicodechar{ğ¬}{${\bf{s}}$}
\newunicodechar{ğ­}{${\bf{t}}$}
\newunicodechar{ğ®}{${\bf{u}}$}
\newunicodechar{ğ¯}{${\bf{v}}$}
\newunicodechar{ğ°}{${\bf{w}}$}
\newunicodechar{ğ±}{${\bf{x}}$}
\newunicodechar{ğ²}{${\bf{y}}$}
\newunicodechar{ğ³}{${\bf{z}}$}

\newunicodechar{âŠ£}{\ensuremath{\dashv}}
\newunicodechar{à¥±}{${}^{\cdot}$}
\newunicodechar{ğ›²”}{${}_{\cdot}$}
\newunicodechar{â‹¯}{$\cdots$}
\newunicodechar{â‡„}{$\rightleftarrows$}
\newunicodechar{â‡†}{$\leftrightarrows$}

\newunicodechar{êœ}{$\raisebox{1ex}{\scalebox{0.5}{\texttt{!}}}$}
\newunicodechar{êœ}{$\raisebox{1ex}{\scalebox{0.5}{\texttt{Â¡}}}$}



%This is notation we will use for categories


\newunicodechar{ğŸ™}{$\mathbb{1}$}
\newunicodechar{âˆ˜}{$\circ$}

%This is notation we will use for twocategories


\newunicodechar{ğŸ}{${\bold{1}}$}
\newunicodechar{â­¢}{$\longrightarrow$}
\newunicodechar{â€¢}{${\bullet}$}
\newunicodechar{âˆ™}{${\bullet}$}

%This is notation we will use for âˆ-â„‚ğ•’ğ•¥

\newunicodechar{ã‚ˆ}{$\includegraphics[width=0.27cm,height=0.27cm]{yon.png}$}
\newunicodechar{âŠ¥}{$\bot$}
\newunicodechar{âˆ¼}{$\sim$}
\newunicodechar{â‰ƒ}{$\simeq$}
\newunicodechar{â‰…}{$\cong$}
\newunicodechar{âˆ}{$\infty$}

\newunicodechar{Î±}{$\alpha$}
\newunicodechar{Î²}{$\beta$}
\newunicodechar{Î³}{$\gamma$}
\newunicodechar{Î´}{$\delta$}
\newunicodechar{Îµ}{$\epsilon$}
\newunicodechar{Î·}{$\eta$}
\newunicodechar{Î¶}{$\zeta$}
\newunicodechar{Î¸}{$\theta$}
\newunicodechar{Î¹}{$\iota$}
\newunicodechar{Î¼}{$\mu$}
\newunicodechar{Îº}{$\kappa$}
\newunicodechar{Î»}{$\lambda$}
\newunicodechar{Ï}{$\rho$}
\newunicodechar{Ï€}{$\pi$}
\newunicodechar{Ïƒ}{$\sigma$}
\newunicodechar{Ï„}{$\tau$}
\newunicodechar{Ï…}{$\upsilon$}
\newunicodechar{Ï†}{$\phi$}
\newunicodechar{Ïˆ}{$\psi$}
\newunicodechar{Î¾}{$\xi$}
\newunicodechar{Ï‡}{$\chi$}
\newunicodechar{Ï‰}{$\omega$}

\newunicodechar{âŠ—}{$\otimes$}

\makeatletter
\newcommand*{\shifttext}[2]{\settowidth{\@tempdima}{#2}\makebox[\@tempdima]{\hspace*{#1}#2}}
\makeatother
\definecolor{Red}{cmyk}{0.1, 0.70, 0.65, 0.00, 1.00}
\definecolor{Blue}{cmyk}{0.9, 0.2, 0.2, 0.00, 1.00}
\definecolor{Yellow}{cmyk}{0.0, 0.00, 0.7, 0.00, 0.5}
\definecolor{Green}{cmyk}{0.6, 0.0, 0.6, 0.00, 1.00}
\definecolor{Purple}{cmyk}{0.8, 0.3, 0.3, 0.00, 1.00}
\definecolor{Orange}{cmyk}{0.0, 0.3, 0.7, 0.00, 1.00}
\definecolor{Grey}{cmyk}{0.13, 0.13, 0.13, 0.00, 1.00}
\newcounter{definitioncounter}
\setcounter{definitioncounter}{1}
\newcounter{theoremcounter}
\setcounter{theoremcounter}{1}
\newcounter{printcounter}
\setcounter{printcounter}{1}
\newcounter{examplecounter}
\setcounter{examplecounter}{1}
\newcounter{ccounter}
\setcounter{ccounter}{1}
\newcounter{pcounter}
\setcounter{pcounter}{1}
\newcounter{lcounter}
\setcounter{lcounter}{1}
\newcounter{sectioncount}
\newcounter{subsectioncount}
\setcounter{sectioncount}{1}
\renewcommand{\section}[1]{\newpage\ \\ \ \\ \begin{center} \scalebox{1.5}{\texttt{\thesectioncount . #1}} \stepcounter{sectioncount} \setcounter{subsectioncount}{1} \end{center} \begin{center} \ \\ \ \\ \thispagestyle{empty} \end{center}}
\renewcommand{\subsection}[1]{\texttt{\thesubsectioncount . #1} \stepcounter{subsectioncount}}
\renewcommand{\backslash}{\reflectbox{\texttt{/}}}

\newcounter{chaptercount}
\renewcommand{\chapter}[1]{
\newpage
{
\Huge 
\begin{center}
\ \\
\ \\
\thispagestyle{empty}
\texttt{#1}
\end{center}}
\ \\
\ \\
}

\newcounter{partcount}
\stepcounter{partcount}
\renewcommand{\part}[1]{
\newpage
{
\Huge 
\begin{center}
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\thispagestyle{empty}
\texttt{PART {\thepartcount}: #1}
\stepcounter{partcount}
\end{center}}
\ \\
\ \\
}


\begin{document}

\thispagestyle{empty} 

\AddToShipoutPicture*
    {\put(540,720){

    \href{http://www.linearlibrary.net}{\includegraphics[width=2cm,height=2cm]{ll.png}}

    }}

\AddToShipoutPicture*
  {\put(470,767){
    \href{https://github.com/linlib/CategoriesandHilbertSpaces/StringDiagramGenerator.py}{\texttt{.py file}}
  }}

\AddToShipoutPicture*
  {\put(470,752){
    \href{https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/TheWhiteheadTheoremandTwoVariations.tex}{\texttt{.tex file}}\\

  }}


\AddToShipoutPicture*
  {\put(470,737){

    \href{https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/TheWhiteheadTheoremandTwoVariations.pdf}{\texttt{.pdf file}}\\

  }}

  \AddToShipoutPicture*
  {\put(470,722){
    \href{https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/TheWhiteheadTheoremandTwoVariations.lean}{\texttt{.lean file}}

  }}

\ \\

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5.8in,colback={white},coltitle=white]
\begin{center}
\ \\
\scalebox{3}{\texttt{The Whitehead Theorem}}\\
\ \\
\scalebox{3}{\texttt{and}}\\
\ \\
\scalebox{3}{\texttt{Two Variations}}\\
\ \\
\end{center}
\end{tcolorbox}
\end{center}
\ \\


\ \\
%LEAN: 
\begin{center}
\begin{tcolorbox}[width=6in,colback={white}]
\begin{center}
\scalebox{0.85}{âˆ€(C:D(âˆ-Cat)),âˆ€(D:D(âˆ-Cat)),âˆ€(F:D(âˆ-Cat).Hom C D),âˆ€(G:D(âˆ-Cat).Hom C D),(âˆ€(n:Nat),(Î âƒ—â‚™ F = Î âƒ—â‚™ G)) â†’ F = G}\\
\ \\
\scalebox{0.85}{âˆ€(X:D(âˆ-Grpd)),âˆ€(Y:D(âˆ-Grpd)),âˆ€(f:D(âˆ-Grpd).Hom X Y),âˆ€(g:D(âˆ-Grpd).Hom X Y),(âˆ€(n:Nat),(Î â‚™ f = Î â‚™ g)) â†’ f = g}\\
\ \\
\scalebox{0.85}{âˆ€(X:D(âˆ-Grpdâ‚‹â‚)),âˆ€(Y:D(âˆ-Grpdâ‚‹â‚)),âˆ€(f:D(âˆ-Grpdâ‚‹â‚).Hom X Y),âˆ€(g:D(âˆ-Grpdâ‚‹â‚).Hom X Y),(âˆ€(n:Nat),(Ï€â‚™ f = Ï€â‚™ g)) â†’ f = g}\\
\end{center}
\end{tcolorbox}
\end{center}

\ \\
\begin{center}
\texttt{Plans to prove the Whitehead theorem}\\
\texttt{in Lean 4, with extensive use of Mathlib 4}
\end{center}
\ \\
\ \\


\thispagestyle{empty}


\newpage

\ \\
\ \\

\begin{center}

\pagecolor{white}
\color{black}

\end{center}

\thispagestyle{empty}




\newpage
\pagecolor{white}
\color{black}
\ \\
\ \\
\thispagestyle{empty}
\large %%%%%%%% HERE IS THE large LARGE size textsize set text size
\newpage 
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\thispagestyle{empty}
 
\newpage



\newpage

\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\

We wish to acknowledge the collaborative efforts of E. Dean Young and Jiazhen Xia. Dean Young initially formulated the introduction with twelve goals, posting them on the Lean Zulip in August of 2023. Together the authors are pursuing these plans as a long term project.\\



\newpage



\newpage
\section{Contents}

The table of contents below reflects the tentative long-term goals of the authors, with the main goal the pursuit of the Whitehead theorem for a point-set model involving Mathlib's predefined homotopy groups.\\

{
\footnotesize
\begin{longtable}{|| l || l ||} 
\hline
\multicolumn{1}{||c||}{$\texttt{Section}$} & \multicolumn{1}{|c||}{$\texttt{Description}$} \\
\hline
\hline
Unfinished & \\
\hline
Contents & \\
\hline
Unicode & \\
\hline
Introduction & \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{PART I: } BASED âˆ-Groupoids} \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 1: }BASED âˆ-Groupoids} \\
\hline \hline
D(âˆ-Grpdâ‚€) & The derived category of BASED âˆ-groupoids \\
\hline
D(âˆ-Grpdâ‚€/Xâ‚€) & The derived category of BASED âˆ-groupoids over Xâ‚€. \\
\hline
Î© : âˆ-Grpdâ‚€ â­¢ âˆ-Grpd & The loop space functor \\
\hline
Î£ : âˆ-Grpdâ‚€ â­¢ âˆ-Grpdâ‚€ & The based suspension functor \\
\hline 
Ï‰ f : âˆ-Grpd/Dâ‚€ â­¢ âˆ-Grpd/Câ‚€ & The homotopy fiber\\
\hline 
Ïƒ f : âˆ-Grpdâ‚€/Câ‚€ â­¢ âˆ-Grpdâ‚€/Dâ‚€ & Based homotopy pushout \\
 \hline 
Ï€â‚™ : âˆ-Grpdâ‚€ â­¢ Set & The connected components functors\\
 \hline \hline
  \multicolumn{2}{||c||}{\texttt{Chapter 2: }The Whitehead Theorem for BASED âˆ-Groupoids} \\
\hline \hline
Globular Sets & Defining globular sets\\
\hline
HEP for BASED âˆ-groupoids & The homotopy extension property for âˆ$\texttt{-Grpd}$â‚€\\
 \hline 
REP for BASED âˆ-groupoids & The replacement functor on âˆ$\texttt{-Grpd}$â‚€ \\
\hline
Whitehead theorem (c) & A map $\texttt{F : D(}$âˆ$\texttt{-Grpdâ‚€).Hom Eâ‚€ Bâ‚€}$ is determined by $\texttt{Î»(n:Nat),Ï€â‚™ F}$. \\
\hline \hline
  \multicolumn{2}{||c||}{\texttt{Chapter 3: }The Category of Maps} \\
\hline \hline
HEP for Maps of BASED âˆ-groupoids & The homotopy extension property for âˆ$\texttt{-Grpd}$â‚€\\
 \hline 
REP for Maps of BASED âˆ-groupoids & The replacement functor on âˆ$\texttt{-Grpd}$â‚€ \\
\hline
The Whitehead theorem for Maps & ... \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{PART II: } âˆ-Groupoids} \\
\hline \hline 
\multicolumn{2}{||c||}{\texttt{Chapter 4: }âˆ\texttt{-Grpd}}\\
\hline \hline
D(âˆ-Grpd) & The derived category of âˆ-groupoids \\
\hline
D(âˆ-Grpd/X) & The derived category of âˆ-groupoids over X \\
\hline
Î©âƒ¡ : âˆ-Grpd â­¢ âˆ-Grpd & The directed path space functor \\
 \hline 
Î£âƒ¡ : âˆ-Grpd â­¢ âˆ-Grpd & The unbased suspension functor \\
 \hline 
Ï‰âƒ¡ f : âˆ-Grpdâ„D â­¢ âˆ-Grpd/C & The directed homotopy pullback functor\\
\hline 
Ïƒâƒ¡ f : âˆ-Grpd/C â­¢ âˆ-Grpd/D & Homotopy pushout with a point \\
 \hline 
Î â‚™ : âˆ-Grpd â­¢ Set & The connected components functors\\
 \hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 5: }The Whitehead Theorem for âˆ-Groupoids} \\
\hline \hline
Cubical Complexes & ...\\
\hline
REP for âˆ-groupoids & The cofibrant replacement functor for âˆ-groupoids\\
\hline
HEP for âˆ-groupoids & The homotopy extension property\\
\hline
Whitehead theorem (b) & A map $\texttt{F : D(}$âˆ$\texttt{-Grpd).Hom E B}$ is determined by $\texttt{Î»(n:Nat),}$Î â‚™
$\texttt{F}$. \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 6: }The Category of Maps of âˆ-Groupoids} \\
\hline \hline
... & ...\\
\hline
REP for Maps of âˆ-groupoids & The replacement functor on âˆ$\texttt{-Grpd}$ \\
\hline
HEP for Maps of âˆ-groupoids & The homotopy extension property for âˆ$\texttt{-Grpd}$\\
 \hline 
The Whitehead theorem for Maps of âˆ-groupoids & ... \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{PART II: } BASED âˆ-CATEGORIES} \\
\hline \hline 
\multicolumn{2}{||c||}{\texttt{Chapter 4: }âˆ\texttt{-...}}\\
\hline \hline
D(âˆ-Grpd) & The derived category of âˆ-groupoids \\
\hline
D(âˆ-Grpd/X) & The derived category of âˆ-groupoids over X \\
\hline
Î©âƒ¡ : âˆ-Grpd â­¢ âˆ-Grpd & The directed path space functor \\
 \hline 
Î£âƒ¡ : âˆ-Grpd â­¢ âˆ-Grpd & The unbased suspension functor \\
 \hline 
Ï‰âƒ¡ f : âˆ-Grpdâ„D â­¢ âˆ-Grpd/C & The directed homotopy pullback functor\\
\hline 
Ïƒâƒ¡ f : âˆ-Grpd/C â­¢ âˆ-Grpd/D & Homotopy pushout with a point \\
 \hline 
Î â‚™ : âˆ-Grpd â­¢ Set & The connected components functors\\
 \hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 5: }The Whitehead Theorem for âˆ-Groupoids} \\
\hline \hline
Cubical Complexes & ...\\
\hline
REP for âˆ-groupoids & The cofibrant replacement functor for âˆ-groupoids\\
\hline
HEP for âˆ-groupoids & The homotopy extension property\\
\hline
Whitehead theorem (b) & A map $\texttt{F : D(}$âˆ$\texttt{-Grpd).Hom E B}$ is determined by $\texttt{Î»(n:Nat),}$Î â‚™
$\texttt{F}$. \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 6: }The Category of Maps of âˆ-Groupoids} \\
\hline \hline
... & ...\\
\hline
REP for Maps of âˆ-groupoids & The replacement functor on âˆ$\texttt{-Grpd}$ \\
\hline
HEP for Maps of âˆ-groupoids & The homotopy extension property for âˆ$\texttt{-Grpd}$\\
 \hline 
The Whitehead theorem for Maps of âˆ-groupoids & ... \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{PART III: } âˆ-Categories} \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 7: }âˆ\texttt{-Cat}} \\
\hline \hline
D(âˆ-Cat) & The derived category of âˆ-categories \\
\hline
D(âˆ-Catâ„C) & The derived category of âˆ-categories over C \\
\hline
Î©âƒ— : âˆ-Cat â­¢ âˆ-Cat & The directed path space functor \\
 \hline 
 Î£âƒ— : âˆ-Cat â­¢ âˆ-Cat & The directed unbased suspension \\
\hline 
Ï‰âƒ— f : âˆ-Catâ„D â­¢ âˆ-Cat/C & The directed homotopy pullback functor\\
 \hline 
 Ïƒâƒ— f : âˆ-Cat/C â­¢ âˆ-Cat/D & The directed homotopy pushout \\
 \hline 
Î âƒ—â‚™ : âˆ-Cat â­¢ Set & The connected components functors\\
 \hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 8: }The Whitehead Theorem for âˆ-Categories} \\
\hline \hline
Directed Cubical Complexes & ...\\
\hline
REP for âˆ-categories & The cofibrant replacement functor for âˆ-categories\\
\hline
HEP for âˆ-categories & The directed homotopy extension property\\
\hline 
Whitehead theorem (a) & A map $\texttt{F : D(}$âˆ$\texttt{-Cat).Hom E B)}$ is determined by $\texttt{Î»(n:Nat),}$Î âƒ—â‚™$\texttt{F}$.\\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 9: }The Category of Maps of âˆ-Categories} \\
\hline \hline
REP for Maps of âˆ-groupoids & The replacement functor on âˆ$\texttt{-Grpd}$ \\
\hline
HEP for Maps of âˆ-groupoids & The homotopy extension property for âˆ$\texttt{-Grpd}$\\
 \hline 
The Whitehead theorem for Maps of âˆ-groupoids & ... \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{PART IV: } A${}^{\infty}$ OPERADS AND OPEROIDS} \\
\hline \hline
 &  \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{PART V: } THE MODEL STRUCTURES ON â–¡ âˆ-Grpd and â–¡ âˆ-Cat} \\
\hline \hline
 & \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{PART I: } âˆ-SPACES} \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 1: }Abelian Groups} \\
\hline \hline
abeliangroup & The type of abelian groups \\
\hline
Maps of abelian groups & Constructing homomorphisms of abelian groups \\
\hline
Negation & \\
\hline
The Eckman-Hilton Argument & \\
\hline
AbelianGroup â­¢ Group & The forgetful functor from abelian groups to groups \\
\hline
Eilenberg-Maclane Spaces & \\
\hline
Chain Complexes & \\
\hline
Realization of Chain Complexes & \\
\hline
Tensor Product of Chain Complexes & \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 2: }âˆ-Spaces} \\
\hline \hline
âˆ-space & The type of âˆ-spaces \\
\hline
Maps of âˆ-spaces & Constructing maps of âˆ-spaces \\
\hline
Negation & \\
\hline
The Eckman-Hilton Argument & \\
\hline
OperadicGroup OperadicGroup âˆ-Grpdâ‚‹â‚ â­¢ OperadicGroup âˆ-Grpdâ‚‹â‚ & \\
\hline
BÂ¹ and Bâ¿ & \\
\hline
[Eâƒ—.obj â„•, -] & Internal Complexes \\
\hline
Realization of Chain Complexes & \\
\hline
Tensor Product of Chain Complexes & \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 3: }Tensor Product of Abelian Groups} \\
\hline \hline
- âŠ—\_(AbelianGroups) - & Mathlib's tensor product of abelian groups \\
\hline
[-,-]\_(AbelianGroups) & Mathlib's hom of abelian groups\\
\hline
AbelianGroup & The symmetric monoidal category of abelian groups\\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 4: }Tensor Product of âˆ-Spaces} \\
\hline \hline
- âŠ—\_(âˆ-Space) - &  \\
\hline
[-,-]\_(âˆ-Space) &  \\
\hline
âˆ-Space & The symmetric monoidal category of âˆ-spaces \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 5: }Setâ‚‹â‚ â‡„ AbelianGroups} \\
\hline \hline
??? & The free abelian group functor \\
 \hline
??? & The forgetful functor from abelian groups to pointed sets \\
 \hline
??? : Setâ‚‹â‚ â‡„ AbelianGroup : ??? & The adjunction between pointed sets and abelian groups \\
\hline \hline
 \multicolumn{2}{||c||}{\texttt{Chapter 6: }âˆ-Grpdâ‚‹â‚ â‡„ âˆ-Space} \\
\hline \hline
??? & The free âˆ-space given a based âˆ-groupoid \\
\hline
??? & The forgetul functor from âˆ-spaces to âˆ-groupoids \\
\hline
??? : âˆ-Grpdâ‚‹â‚ â‡„ âˆ-Space : ??? & The ??? between âˆ-Grpdâ‚‹â‚ and âˆ-Spaces \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{PART II: } RINGS, COMMUTATIVE RINGS, A${}^{\infty}$-RINGS, AND E${}^{\infty}$-RINGS} \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 7: }Rings and Commutative Rings} \\
\hline \hline
ring & The type of rings \\
 \hline
Ring & The category of rings \\
\hline
commutative\_ring & The type of commutative rings  \\
\hline
CommutativeRing & The category of commutative rings \\
 \hline \hline
  \multicolumn{2}{||c||}{\texttt{Chapter 8: }A${}^{\infty}$-Rings and E${}^{\infty}$-Rings} \\
\hline \hline
A${}^{\infty}$-ring & The type of A${}^{\infty}$-rings \\
\hline
A${}^{\infty}$-Ring & The category of A${}^{\infty}$-Rings \\
 \hline
E${}^{\infty}$-ring  & The type of E${}^{\infty}$-rings \\
 \hline
E${}^{\infty}$-Ring  & The category of E${}^{\infty}$-Rings \\
 \hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 9: }Modules and Modules over Commutative Rings} \\
\hline \hline
 &  \\
 \hline
 &  \\
 \hline
InternalMonoidAction (InternalMonoid C) â‰… InternalMonoid (InteralMonoidAction C) & The ??? theorem \\ 
\hline
CommutativeAlgebra : CommutativeRing â†’ Cat & The category of commutative algebras \\
\hline
Maps (Algebra A) : Cat & The category of maps of commutative A-algebras \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 10: }A${}^{\infty}$-Modules and E${}^{\infty}$-Modules} \\
\hline \hline
 &  \\
\hline
 &  \\
\hline
$A{}^{\infty}$-RingAction ($A{}^{\infty}$-Ring C) â‰… $A{}^{\infty}$-Ring ($A{}^{\infty}$-RingAction C) & The ??? theorem \\ 
\hline
Maps A${}^{\infty}$-Algebras & \\
 \hline \hline
\multicolumn{2}{||c||}{\texttt{PART III: } DERIVATIONS AND CONNECTIONS} \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 11: }Lie Algebras} \\
\hline \hline
lie\_algebra & The type of Lie-algebras \\
\hline
LieAlgebra & The category of Lie-algebras \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 12: }Derivations} \\
\hline \hline
InternalAbelianGroup (Maps (Algebra A)) â‰… MonoidActionObject A & ??? \\
\hline
??? : (Maps (Algebra A)) â‡„ InternalAbelianGroup (Maps (Algebra A)) : ??? & The free abelian group functor for (Maps (Algebra A)) \\
\hline
Î› : ??? â‡„ ??? : FstDeg & \\ 
\hline
??? : (Algebra A) â‡„ [Eâƒ—.obj â„•, (Algebra A)] : ??? & The free DGA functor \\
\hline 
derivation & Definition of a derivation \\
\hline
Der : () â‡„ (InternalMonoidAction A) : ??? & A derivation is a primitive element \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 13: }L${}^{\infty}$ Algebras} \\
\hline \hline
Lâ±â¿á¶ \_algebra & The type of L${}^{\infty}$-algebras  \\
\hline
L${}^{\infty}$Algebra &  \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 14: }âˆ-Derivations} \\
\hline \hline
OperadicAbelianGroup (Maps (âˆ-Algebra A)) â‰… E${}^{\infty}$-MonoidAction A & ??? \\
\hline
??? : $A{}^{\infty}$-Algebras â‡„ ???  & The free abelian group \\
\hline
Î› : ??? â‡„ ??? : FstDeg &  \\ 
\hline
??? : (???) â‡„ (???) : ??? & The free ??? \\
\hline
âˆ-derivation & Definition of an âˆ-derivation \\
\hline
âˆ-Der : () â‡„ () : ??? & A derivation is an âˆ-primitive element \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 15: }Tensor Product of Lie Algebras} \\
\hline \hline
- âŠ—\_() - &  \\
\hline
LieAlgebra : ??? & The monoidal category of Lie algebras\\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 16: }Tensor Product of L${}^{\infty}$-Algebras} \\
\hline \hline
- âŠ—\_() - & \\ 
 \hline
 : ??? & The symmetric monoidal category of L${}^{\infty}$-algebras \\
 \hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 17: }Lie Algebra Representations} \\
\hline \hline
 & \\
\hline
 & \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 18: }Connections} \\
\hline \hline
??? & The ??? equivalence \\
\hline
??? & The free internal abelian group action functor \\
\hline
??? & The first degree of the free E${}^{\infty}$-DGM on an algebra is s\_() \\
\hline
???   & ??? \\
\hline
connection & Definition of a connection \\
\hline
??? & A connection is a d-action \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 19: }L${}^{\infty}$-Representations} \\
\hline \hline
 & \\
\hline
 & \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 20: }âˆ-Connections} \\
\hline \hline
??? & The ??? equivalence \\
\hline
??? & The free operadic abelian group action functor \\
\hline
??? & The first degree of the free E${}^{\infty}$-DGM on an algebra is sâ±â¿á¶ \_() \\
\hline
???  & ??? \\
\hline
connection & Definition of a connection \\
\hline
??? & A connection is a dâ±â¿á¶ -action\\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 21: }Tensor Product of Lie-Algebra Representations} \\
\hline \hline
- âŠ—\_() - &  \\
\hline
[-,-]\_() &  \\
\hline
??? & The symmetric monoidal closed category of Lie-algebra representations \\
\hline \hline
\multicolumn{2}{||c||}{\texttt{Chapter 22: }Tensor Product of L${}^{\infty}$-Algebra Representations} \\
\hline \hline
- âŠ—\_() -  &  \\
 \hline
[-,-]\_() - &  \\
 \hline
??? & The symmetric monoidal closed category of L${}^{\infty}$-algebra representations\\
 \hline \hline
\end{longtable}
}



\newpage
\section{Introduction}

{\bf The main goal of this repository is to prove the Whitehead theorem in Lean 4 using Mathlib 4's homotopy groups}. Two other subsequent goals are to state and prove two variations of the Whitehead theorem. It is important that initial pull requests stemming from our work remain basic and accessible; we hope to make progress which is gradual and incremental.\\

Besides this goal, we have three others. Here are the four heorems which will form our main goals:

\begin{enumerate}[(a)]
\item (The Whitehead theorem for based âˆ-groupoids) âˆ€(E:D(âˆ-Grpdâ‚‹â‚)),âˆ€(B:D(âˆ-Grpdâ‚‹â‚)),âˆ€(F:D(âˆ-Grpdâ‚‹â‚).Hom E B),âˆ€(G:D(âˆ-Grpdâ‚‹â‚).Hom E B),(âˆ€(n:Nat),(Ï€â‚™ F = Ï€â‚™ G)) â†’ F = G, where Ï€â‚™ is notation for Ï€ n, where Ï€ n : Functor D(âˆ-Grpdâ‚‹â‚) Set.
\item (The Whitehead theorem for âˆ-groupoids) âˆ€(E:D(âˆ-Grpd)),âˆ€(B:D(âˆ-Grpd)),âˆ€(F:D(âˆ-Grpd).Hom E B),âˆ€(G:D(âˆ-Grpd).Hom E B),(âˆ€(n:Nat),(Î â‚™ F = Î â‚™ G)) â†’ F = G, where Î â‚™ is notation for Î  n, where Î  n : Functor D(âˆ-Grpd) Set.
\item (The Whitehead theorem for based ) âˆ€(E:D(âˆ-Catâ‚‹â‚)),âˆ€(B:D(âˆ-Catâ‚‹â‚)),âˆ€(F:D(âˆ-Catâ‚‹â‚).Hom E B),âˆ€(G:D(âˆ-Catâ‚‹â‚).Hom E B),(âˆ€(n:Nat),(Ï€âƒ—â‚™ F = Ï€âƒ—â‚™ G)) â†’ F = G, where Ï€âƒ—â‚™ is notation for Ï€âƒ— n, where Ï€âƒ— n : Functor D(âˆ-Catâ‚‹â‚) Set.
\item (The Whitehead theorem for âˆ-categories) âˆ€(E:D(âˆ-Cat)),âˆ€(B:D(âˆ-Cat)),âˆ€(F:D(âˆ-Cat).Hom E B),âˆ€(G:D(âˆ-Cat).Hom E B),(âˆ€(n:Nat),(Î âƒ—â‚™ F = Î âƒ—â‚™ G)) â†’ F = G, where Î âƒ—â‚™ is notation for Î âƒ— n, where Î âƒ— n : Functor D(âˆ-Catâ‚‹â‚) Set.
\end{enumerate}

(a) in the above reflects the known Whitehead theorem, which dates back to Whitehead's two papers titled `Combinatorial Homotopy I' and `Combinatorial Homotopy II'. There is also a fourth Whitehead theorem.\\

We will use two models of each of the following categories in the theorems above:

\begin{enumerate}[(i)]
\item We model âˆ-Grpdâ‚‹â‚ : Cat using based CW-complexes.
\item We model âˆ-Grpd : Cat using CW-complexes.
\item We model âˆ-Catâ‚‹â‚ : Cat using based directed CW-complexes.
\item We model âˆ-Cat : Cat using directed CW-complexes.
\end{enumerate}

This choice accords with the standard approach to the third theorem, in which one typically chooses both a combinatorial and point-set model, with the former featuring a \href{https://github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/AlgebraicTopology/SimplicialSet.lean#L235-L236}{geometric realization functor} into the latter.\\

We will use $\texttt{Mathlib 4}$'s category theory, particularly

\begin{enumerate}
\item Categories (see Mathlib's $\texttt{Category X}$)
\item Functors (see Mathlib's $\texttt{Functor C D}$)
\item Natural transformations (see Mathlib's $\texttt{NatTrans F G}$)
\item Equations between natural transformations (see Mathlib's $\texttt{NatExt}$ here; these are related to our $\texttt{equation}$)
\end{enumerate}

While the functors Ï€â‚™ occuring in the main theorems above are already defined in $\texttt{Mathlib 4}$ for the desired point-set model, the functors Ï€â‚™, Î â‚™, and Î âƒ—â‚™ are not. The existence of a base point makes Ï€â‚™ relatively straightforward to define. Here are their types:

\begin{enumerate}[(i)]
\item Ï€â‚™ : Functor D(âˆ-Grpdâ‚‹â‚) Set (???)
\item Ï€âƒ—â‚™ : Functor D(âˆ-Catâ‚‹â‚) Set
\item Î â‚™ : Functor D(âˆ-Grpd) Set
\item Î âƒ—â‚™ : Functor D(âˆ-Cat) Set
\end{enumerate}

 We also form their derived functors:

\begin{enumerate}[(i)]
\item D(Ï€â‚™) : Functor D(âˆ-Grpdâ‚‹â‚) Set
\item D(Ï€âƒ—â‚™) : Functor D(âˆ-Catâ‚‹â‚) Set
\item D(Î â‚™) : Functor D(âˆ-Grpd) (Glb â†’$\_(Cat)$ Sets)
\item D(Î âƒ—â‚™) : Functor D(âˆ-Cat) (Glb â†’$\_(Cat)$ Sets)
\end{enumerate}

Where Glb â†’$\_(Cat)$ Sets is the category of globular sets. In the course of the repository we will need the directed path space, path space, and loop space functors as well, which fit with the analogy formed by the Whitehead theorem and its two variations:

\begin{enumerate}
\item Î© : Functor âˆ-Grpdâ‚‹â‚ âˆ-Grpdâ‚‹â‚
\item Î©âƒ— : Functor âˆ-Catâ‚‹â‚ âˆ-Catâ‚‹â‚
\item [Î³,-] : Functor âˆ-Grpd âˆ-Grpd
\item [Î³âƒ—,-] : Functor âˆ-Grpd âˆ-Grpd
\end{enumerate}

Where Î³ is the unit interval and Î³âƒ— is the directed unit interval.\\

\iffalse
The latter, developed first, features a deformation retraction Î³âƒ— $\leftrightarrow$ Î³âƒ—Â² between the directed unit interval and its cartesian product with itself.\\
\fi

\iffalse
In the directed context, a homotopy between two maps in âˆ-Catâ„C consists of a sequence of compatible directed homotopies with the odd morphisms in the sequence formed from reversed copies of Î”Â¹. Really we have two such categories, one of which consists of formal words, and another which involves âˆ-categories and âˆ-functors in the image of $\texttt{repl}$).\\

The main technical feature in the proofs of these theorems concerns a lifting property which successively lifts a homotopy along a single attachment of Î”â¿ along its boundary âˆ‚Î”â¿. A homotopy h : âˆ‚Î”â¿ Ã— Î”Â¹ â­¢ Y between f, g : âˆ‚Î”â¿ â­¢ Y extends to a map H : Î”â¿ Ã— Î”Â¹ â­¢ Y. The directed case requires an extra technical feature. H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary.\\

Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

We will define three different kinds of derived category:\\

\begin{enumerate}
\item D(âˆ-Cat) : Cat (the directed derived category of âˆ-categories)
\item D(âˆ-Grpd) : Cat (the derived category of âˆ-groupoids)
\item D(âˆ-Grpdâ‚€) : Cat (the derived category of based âˆ-groupoids)
\end{enumerate}

We then create the second kind of derived category, one for each of the objects in the respective categories above:

\begin{enumerate}
\item For C : D(âˆ-Cat), a category D(âˆ-Cat/C) : Cat
\item For G : D(âˆ-Grpd), a category D(âˆ-Grpd/G) : Cat
\item For Gâ‚€ : D(âˆ-Grpdâ‚€), a category D(âˆ-Grpdâ‚€/Gâ‚€) : Cat
\end{enumerate}

For the model built on simplicial sets, Î©âƒ— will be representable by Î”Â¹ with respect to an internal hom, and Î©âƒ¡ will be representable by a model of the unit interval I := [0,1].\\

We will use six (strict) ``internal'' structures in addition to the standard structures in category theory:

\begin{enumerate}[(i)]
\item InternalCategory : Cat â†’ Cat 
\item InternalPresheaf : (X : Cat) â†’ (C : (InternalCategory X)) â†’ Cat
\item InternalGroupoid : Cat â†’ Cat
\item InternalGroupoidAction : (X : Cat) â†’ (G : (InternalGroupoid X)) â†’ Cat
\item InternalGroup : Cat â†’ Cat
\item InternalGroupAction : (X : Cat) â†’ (Gâ‚€ : (InternalGroup X)) â†’ Cat   
\end{enumerate}

The book ``Galois theories" by Borceux and Janelidze contains the internal structures (iii), (iv), (v), and (vi), and the first two internal structures have fewer entries. That book details how to think about Galois theory using internal groupoids, internal G-presheaves, monadicity, comonadicity, and the constructions involved in Eilenberg-Moore theory.\\

Some previous work done on these structures can be found at the thread \href{https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Internal.20categories}{here}.\\

The six internal structures above arise here in relation to six functors:

\begin{enumerate}[(I)]
\item Î©âƒ— : âˆ-Cat â­¢ âˆ-Cat (notation for the directed path space functor, related to [Î”Â¹,-]). D(Î©âƒ—) factors through internal categories in D(âˆ-Cat) by a categorical equivalence D(âˆ-Cat) â‰… InternalCategory D(âˆ-Cat) (internal categories in D(âˆ-Cat))
\item Ï‰âƒ— (ğŸ™ C) : âˆ-Cat/C â­¢ âˆ-Cat/C, the derived directed homotopy pullback with ğŸ™ C. D(Ï‰âƒ— (ğŸ™ C)) factors through a categorical equivalence between D(âˆ-Cat/C) and internal Pâƒ—C-presheaves in D(âˆ-Cat/C).
\item Î©âƒ¡ : âˆ-Grpd â­¢ âˆ-Grpd (notation for the path space functor [I,-]), the derived homotopy pullback of an âˆ-groupoid with itself. D(Î©âƒ¡) factors through a categorical equivalence between D(âˆ-Grpd) and internal groupoids in D(âˆ-Grpd)
\item Ï‰âƒ¡ (ğŸ™ X) : âˆ-Grpd/X â­¢ âˆ-Grpd/X, the derived homotopy pullback with ğŸ™ X. D(Ï‰âƒ¡ (ğŸ™ X)) factors through internal Pâƒ¡X
\item Î© : âˆ-Grpdâ‚€ â­¢ âˆ-Grpdâ‚€, the loop space functor. D(Î©) factors through a categorical equivalence between D(âˆ-Grpdâ‚€) and internal groups in D(âˆ-Grpdâ‚€) (the loop space functor on connected based âˆ-groupoids)
\item Ï‰ (ğŸ™ X) : âˆ-Grpdâ‚€/Xâ‚€ â­¢ âˆ-Grpdâ‚€/Xâ‚€, the homotopy pullback with the base of Xâ‚€. D(Ï‰ (ğŸ™ X)) factors through internal PXâ‚€-actions in BASED spaces over Xâ‚€.
\end{enumerate}

(v) in the above is shown \href{https://mathoverflow.net/questions/128883/why-omega-x-and-bg-are-adjoint-functors}{here} and (vi) in the above is shown in a typical exposition of $G$-principal bundles.\\

The functors Ï‰âƒ— (ğŸ™ C), Ï‰âƒ¡ (ğŸ™ X), and Ï‰ (ğŸ™ C) in the above ensue from a more general construction:\\

\begin{enumerate}
\item For C, D : D(âˆ-Cat), and f : C â­¢ D, Ï‰âƒ— f : D(âˆ-Cat/D) â­¢ D(âˆ-Cat/C)   (derived directed homotopy pullback)
\item For B, E : D(âˆ-Grpd), and f : E â­¢ B, Ï‰âƒ¡ f : D(âˆ-Grpd/B) â­¢ D(âˆ-Grpd/E) (derived homotopy pullback)
\item For Bâ‚€, Eâ‚€ : D(âˆ-Grpdâ‚€), and f : Eâ‚€ â­¢ Bâ‚€, Ï‰ f : D(âˆ-Grpdâ‚€/Bâ‚€) â­¢ D(âˆ-Grpdâ‚€/Eâ‚€) (homotopy pullback with the base)
\end{enumerate}

These six factored functors Pâƒ— , Pâƒ¡ , P : D(âˆ-Grpdâ‚€), pâƒ— (ğŸ™ C), pâƒ¡ (ğŸ™ X), p are each fully faithful and produce categorical equivalences; we later construct functors Bâƒ—, Bâƒ¡, B, bâƒ—, bâƒ¡, b defined on the essential image of these six, which are inverse to them up to natural isomorphism.\\

We obtain six categorical equivalences witnessed by these twelve functors (along with twelve natural isomorphisms). Here are the types of Pâƒ— , Pâƒ¡ , P : D(âˆ-Grpdâ‚€), pâƒ— (ğŸ™ C), pâƒ¡ (ğŸ™ X), p:

\begin{enumerate}
\item The directed path space, the path space, and loop space form components of the functors Pâƒ—, Pâƒ¡, and P, which are valued in internal categories, internal groupoids, and internal groups respectively.
\begin{enumerate}
\item Pâƒ— : D(âˆ-Cat) â­¢ Cat D(âˆ-Cat)
\item Pâƒ¡ : D(âˆ-Grpd) â­¢ Grpd D(âˆ-Grpd)
\item P : D(âˆ-Grpdâ‚€) â­¢ Grp D(âˆ-Grpd) (see \href{https://mathoverflow.net/questions/128883/why-omega-x-and-bg-are-adjoint-functors}{here})
\end{enumerate}
\item The directed homotopy pullback, the homotopy pullback, and the homotopy pullback with the base form components of the functors Alg(Mon(Ï‰âƒ—)), Alg(Mon(Ï‰âƒ¡)), and Alg(Mon(p)), respectively. 
\begin{enumerate}
\item pâƒ— (ğŸ™ C) : D(âˆ-Catâ„C) â­¢ InternalPresheaf D(âˆ-Catâ„C) Pâƒ—.obj C 
\item pâƒ¡ (ğŸ™ X) : D(âˆ-Grpdâ„X) â­¢ InternalGroupoidAction D(âˆ-Grpdâ„X) Pâƒ¡.obj X
\item p (ğŸ™ Xâ‚€) : D(âˆ-Grpdâ‚€â„Xâ‚€) â­¢ InternalGroupAction D(âˆ-Grpdâ‚€â„Xâ‚€) P.obj Xâ‚€
\end{enumerate}
\end{enumerate}

Above, the functors Pâƒ—, Pâƒ¡, P, pâƒ—, pâƒ¡, and p feature Î©âƒ—, Î©âƒ¡, Î©, Ï‰âƒ—, Ï‰âƒ¡, and Ï‰ in their components, and can be related to them using constructions from Eilenberg-Moore theory.\\
\fi

\iffalse
Interspersing one of the 6 omegas's in each of six operadic structures, which have the same number of entries as the six internal structures respectively. In the thirteen entry operadic category, one of the entries is an ordinary object in the category, analogous to the first of the thirteen entries of the internal category. The second entry, instead of featuring the ordinal 2 (the morphism component, which is the second of two entries in the category in question), features a sequence of objects in the category. The identity morphism Idn : Obj â­¢ Mor of the internal category with 13 entries (as opposed to the slightly more complex structure in which separate clauses assume the existence of the relevant pullbacks so as to create an endofunction of Cat) is analogous to a function also from Oâ‚€ to Oâ‚, and two further entires are essentially shared by both as well: Dom and Cod. One difference occurs in the component of an internal category for the properties that Idn has, which in the operadic case is 
\fi

\iffalse
J : Nat â†’ âˆ-Grpd
\fi

\iffalse
Î©âƒ—, Î©âƒ¡, Î©âƒ—â‚€, Î©âƒ¡â‚€ are the ones I construct and Î© Mathlib's.
\fi

\iffalse
Adding in the operadic structures.
\fi


\iffalse
https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Internal.20categories
\fi

\iffalse
{
\footnotesize
\begin{center}
\begin{tabular}{||l || l || l || l ||} 
 \hline
  \multicolumn{4}{||c||}{\texttt{Twelve Structures}} \\
 \hline
 \multicolumn{2}{||c||}{\texttt{Strict}}  &  \multicolumn{2}{||c||}{\texttt{Lax}} \\
 \hline
 \texttt{Unitial} &  \texttt{Actional}  &  \texttt{Unitial} &  \texttt{Actional}\\
 \hline \hline
 \texttt{InternalCategory}  & \texttt{InternalPresheaf} & \texttt{OperadicCategory} & \texttt{OperadicPresheaf} \\ 
 \hline
 \texttt{InternalGroupoid} & \texttt{InternalGroupoidAction} & \texttt{OperadicGroupoid} & \texttt{OperadicGroupoidAction} \\ 
 \hline
\texttt{InternalGroup} & \texttt{InternalGroupAction} & \texttt{OperadicGroup} & \texttt{OperadicGroupAction} \\ 
 \hline 
\end{tabular}
\end{center}
}
\fi

\iffalse
{\footnotesize
\begin{center}
\scalebox{1.1}{
\begin{tabular}{|| l | l || l | l || } 
\hline
\hline
\multicolumn{2}{||c||}{Internal} & \multicolumn{2}{||c||}{Operadic} \\
\hline
\multicolumn{2}{||c||}{Unitial} & \multicolumn{2}{||c||}{Actional} & \multicolumn{2}{||c||}{Unitial} & \multicolumn{2}{||c||}{Actional} \\
\hline
\hline
$\texttt{InternalCategory : Cat â†’ Cat}$ & $\texttt{InternalPresheaf : (C : Cat) â†’ (InternalCategory C) â†’ Cat}$ & $\texttt{OperadicCategory\_(-) : âˆ-Cat\_(-) â†’ âˆ-Cat\_(-)}$ & OperadicPresheaf\_(-) : (X : âˆ-Cat\_(-)) â†’ âˆ-Cat\_{(-)} \\
\hline
$\texttt{InternalGroupoid\_(-) : Cat\_(-) â†’ Cat\_(-)}$ & $\texttt{InternalGroupoidAction : (C : Cat) â†’ (InternalGroupoid C) â†’ Cat}$& $\texttt{OperadicGroupoid\_(-) : âˆ-Cat\_(-) â†’ âˆ-Cat\_(-)}$ & OperadicGroupoidAction\_(-) : (OperadicGroupoid\_() C) â†’ (InternalCategory C) â†’ âˆ-Cat\_(-) â†’ âˆ-Cat\_(-) \\
\hline
$\texttt{InternalMonoid\_(-) : Cat\_(-) â†’ Cat\_(-)}$ & $\texttt{InternalMonoidAction : (C : Cat) â†’ (InternalMonoid C) â†’ Cat}$ & $\texttt{OperadicMonoid\_(-) : âˆ-Cat\_(-) â†’ âˆ-Cat\_(-)}$ & $\texttt{OperadicMonoidAction}$\_$\texttt{(-) : âˆ-Cat\_(-) â†’ âˆ-Cat\_(-)}$\\
\hline
$\texttt{InternalGroup\_(-) : Cat\_(-) â†’ Cat\_(-)}$ & $\texttt{InternalGroupAction : (C : Cat) â†’ (InternalGroup C) â†’ Cat}$ & $\texttt{OperadicGroup\_(-) : âˆ-Cat\_(-) â†’ âˆ-Cat\_(-)}$ & $\texttt{OperadicGroupAction}$\_$\texttt{(-) : âˆ-Cat\_(-) â†’ âˆ-Cat\_(-)}$\\
 \hline
\end{tabular}}
\end{center}}
\fi

\iffalse
\ \\
{\footnotesize
\begin{center}
\scalebox{1.1}{
\begin{tabular}{|| l || l ||} 
\hline
\hline
Î©âƒ— : âˆ-Cat â­¢ âˆ-Cat & Ï‰âƒ— : (C : âˆ-Cat) â†’ (D : âˆ-Cat) â†’ (F : âˆ-Cat.hom C D) â†’ (âˆ-Catâ„D) â­¢ âˆ-Cat \\
\hline
Oâƒ— : âˆ-Cat â­¢ OperadicCategory âˆ-Cat & oâƒ— : (C : âˆ-Cat) â†’ (D : âˆ-Cat) â†’ (F : âˆ-Cat.hom C D) â†’ (âˆ-Catâ„D) â­¢ OperadicPresheaf (Oâƒ—.obj D)\\
\hline
Pâƒ— : âˆ-Cat â­¢ InternalCategory D(âˆ-Cat) & pâƒ— : (C : âˆ-Cat) â†’ (D : âˆ-Cat) â†’ (F : âˆ-Cat.hom C D) â†’ (âˆ-Catâ„D) â­¢ InternalPresheaf (Pâƒ—.obj D) \\
\hline
\hline
Î©âƒ¡ : âˆ-Grpd â­¢ âˆ-Grpd & Ï‰âƒ¡ : (X : âˆ-Grpd) â†’ (Y : âˆ-Grpd) â†’ (F : âˆ-Cat.hom X Y) â†’ (âˆ-Grpdâ„Y) â­¢ âˆ-Grpd \\
\hline
Oâƒ¡ : âˆ-Grpd â­¢ OperadicGroupoid âˆ-Grpd & oâƒ¡ : (X : âˆ-Grpd) â†’ (Y : âˆ-Grpd) â†’ (F : âˆ-Cat.hom X Y) â†’ (âˆ-Grpdâ„Y) â­¢ OperadicGroupoidAction (Oâƒ¡.obj Y) \\
\hline
Pâƒ¡ : âˆ-Grpd â­¢ InternalGroupoid D(âˆ-Grpd) & pâƒ¡ : (X : âˆ-Grpd) â†’ (Y : âˆ-Grpd) â†’ (F : âˆ-Cat.hom C D) â†’ (âˆ-Grpdâ„Y) â­¢ InternalGroupoidAction (Pâƒ¡.obj Y)  \\
\hline
\hline
Î© : âˆ-Grpdâ‚‹â‚ â­¢ âˆ-Grpdâ‚‹â‚  & Ï‰ : (Xâ‚‹â‚ : âˆ-Grpdâ‚‹â‚) â†’ (Yâ‚‹â‚ : âˆ-Grpdâ‚‹â‚) â†’ (F : âˆ-Grpdâ‚‹â‚.hom Xâ‚‹â‚ Yâ‚‹â‚) â†’ (âˆ-Grpdâ‚‹â‚â„Yâ‚‹â‚) â­¢ âˆ-Grpdâ‚‹â‚ \\
\hline
O : âˆ-Grpdâ‚‹â‚ â­¢ OperadicGroup âˆ-Grpdâ‚‹â‚ & o : (Xâ‚‹â‚ : âˆ-Grpdâ‚‹â‚) â†’ (Yâ‚‹â‚ : âˆ-Grpdâ‚‹â‚) â†’ (F : âˆ-Grpdâ‚‹â‚.hom Xâ‚‹â‚ Yâ‚‹â‚) â†’ (âˆ-Grpdâ‚‹â‚â„Yâ‚‹â‚) â­¢ OperadicGroupAction (O.obj X) \\
\hline
P : âˆ-Grpdâ‚‹â‚ â­¢ InternalGroup D(âˆ-Grpdâ‚‹â‚) & p : (Xâ‚‹â‚ : âˆ-Grpdâ‚‹â‚) â†’ (Yâ‚‹â‚ : âˆ-Grpdâ‚‹â‚) â†’ (F : âˆ-Grpdâ‚‹â‚.hom Xâ‚‹â‚ Yâ‚‹â‚) â†’ (âˆ-Grpdâ‚‹â‚â„Yâ‚‹â‚) â­¢ InternalGroupAction (P.obj Xâ‚‹â‚) \\
\hline
 \hline
\end{tabular}}
\end{center}}

\fi


\begin{center}
\begin{tabular}{||c||c|c||c|c|}
\hline
\hline
  & \multicolumn{2}{||c||}{Enriched} & \multicolumn{2}{||c||}{Internal} \\
\hline
\hline
$\texttt{Strict Unitial}$  & enriched category & 7 entries & internal category & 13 entries \\ 
\hline
$\texttt{Strict Actional}$ & enriched presheaf & 3 entries & internal presheaf & 5 entries\\ 
\hline
\hline
$\texttt{A}^{\infty}$ $\texttt{Unitial}$  & enriched $A^{\infty}$-operoid & 7 entries & internal $A^{\infty}$-operoid action & 13 entries \\ 
\hline
$\texttt{A}^{\infty}$ $\texttt{Actional}$ & enriched $A^{\infty}$-operoid action & 3 entries & internal $A^{\infty}$-operad action & 5 entries \\ 
\hline
\hline
\end{tabular}
\end{center}





\iffalse
â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ 
â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        
â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        
â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘   
â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        
â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        
 â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘
\fi
\newpage
\section{Unicode}

Here is a list of the unicode characters we will use:

{\footnotesize
\begin{center}
\begin{tabular}{|| l || l || l || l ||} 
\hline
$\texttt{Symbol}$ & $\texttt{Unicode}$ & \texttt{VSCode shortcut} & $\texttt{Use}$\\
\hline
\hline
\multicolumn{4}{||c||}{\texttt{Lean's Kernel}} \\
\hline
\hline
Ã— & 2A2F & \backslash\texttt{times} & Product of types\\
\hline
â†’ & 2192 & \backslash\texttt{rightarrow}  & Hom of types\\
\hline
âŸ¨,âŸ© & 27E8,27E9 & \backslash\texttt{langle},\backslash\texttt{rangle}  & Product term introduction\\
\hline
â†¦ & 21A6 &\backslash\texttt{mapsto}  & Hom term introduction\\
\hline
âˆ§ & 2227 &\backslash\texttt{wedge}  & Conjunction \\
\hline
âˆ¨ & 2228 &\backslash\texttt{vee}  & Disjunction \\
\hline
âˆ€ & 2200 &\backslash\texttt{forall}  & Universal quantification \\
\hline
âˆƒ & 2203 &\backslash\texttt{exists}  & Existential quantification\\
\hline
Â¬ & 00AC &\backslash\texttt{neg}  & Negation\\
\hline
\hline
\multicolumn{4}{||c||}{\texttt{Variables and Constants}} \\
\hline
\hline
áµƒ,áµ‡,á¶œ,...,á¶» & 1D52,1D56 & & Variables and constants \\
\hline
â°,Â¹,Â²,Â³,â´,âµ,â¶,â·,â¸,â¹ & 1D52,1D56 &  & Variables and constants \\
\hline
â» & 207B &  & Variables and constants \\
\hline
â‚€,â‚,â‚‚,â‚ƒ,â‚„,â‚…,â‚†,â‚‡,â‚ˆ,â‚‰ & 2080 - 2089 & \backslash\texttt{0}-\backslash\texttt{9} & Variables and constants\\
\hline
ğ”¸,...,â„¤ & 1D538 &  &  \\
\hline
ğ•’,...,ğ•« & 1D552 &  &  \\
\hline
ğ€,...,ğ™ & 1D41A &  &  \\
\hline
ğš,...,ğ³ & 1D41A &  &  \\
\hline
\texttt{Î±}-\texttt{Ï‰},\texttt{A}-\texttt{Î©} & 03B1-03C9 & & Variables and constants\\
\hline
\hline
\multicolumn{4}{||c||}{\texttt{Categories}} \\
\hline
\hline
 ğŸ™ & 1D7D9 & \backslash\texttt{b1}  & The identity morphism\\
\hline
 âˆ˜ & 2218 & \backslash\texttt{circ}  & Composition\\
 \hline
 \hline
 \multicolumn{4}{||c||}{\texttt{Bicategories}} \\
 \hline 
 \hline
 â€¢ & 2022  & \backslash\texttt{smul}  & Horizontal composition of objects\\ 
  \hline
  \hline
 \multicolumn{4}{||c||}{\texttt{Adjunctions}} \\
\hline
\hline
â‡„ & 21C4 & \backslash\texttt{rightleftarrows}  & Adjunctions \\
\hline
â‡† & 21C6 & \backslash\texttt{leftrightarrows}  & Adjunctions \\
\hline
ğ›²” & 1BC94 &  & Right adjoints\\
\hline
à¥± & 0971 &  & Left adjoints \\
\hline
âŠ£ & 22A3 & \backslash\texttt{dashv}  & The condition that two functors are adjoint \\
\hline
\hline
\multicolumn{4}{||c||}{\texttt{Monads and Comonads}} \\
\hline
\hline
?,Â¿ & 003F, 00BF & ?,\backslash\texttt{?}  & The corresponding (co)monad of an adjunction\\
\hline
!,Â¡ & 0021, 00A1 & !, \backslash\texttt{!}  & The (co)-Eilenberg-(co)-Moore adjunction \\
\hline
êœ,êœ & A71D, A71E &  & The (co)exponential maps\\
\hline
\hline
\multicolumn{4}{||c||}{\texttt{Miscellaneous}} \\
\hline
\hline
âˆ¼ & 223C & \backslash\texttt{sim} & Homotopies \\
\hline
â‰ƒ & 2243 & \backslash\texttt{equiv}  & Equivalences \\
\hline
â‰… & 2245 & \backslash\texttt{cong}  & Isomorphisms \\
\hline
âŠ¥ & 22A5 & \backslash\texttt{bot}  & The overobject classifier \\
\hline
âˆ & 221E & \backslash\texttt{infty}  & Infinity categories and infinity groupoids\\ 
\hline
${}^{\leftrightarrow}$ & 20D7 &  & Homotopical operations on âˆ-categories \\
\hline
${}^{\rightarrow}$ & 20E1 &  & Homotopical operations on âˆ-groupoids \\
\hline
\end{tabular}
\end{center}}

Of these, the characters $\texttt{êœ,êœ,ğ›²”,à¥±}$,${}^{\rightarrow}$, and ${}^{\leftrightarrow}$ do not have VSCode shortcuts.\\

\ \\
\ \\
\ \\

\iffalse
oâƒ— : (C : âˆ-Cat) â†’ âˆ-Catâ„C â­¢ OperadicPresheaf (Oâƒ—.obj C)
oâƒ¡ : (X : âˆ-Grpd) â†’ âˆ-Grpdâ„X â­¢ OperadicGroupoidAction (Oâƒ¡.obj X)
o : (Xâ‚€ : âˆ-Grpdâ‚€) â†’ âˆ-Grpdâ‚€â„Xâ‚€ â­¢ OperadicGroupAction (O.obj Xâ‚€)
\fi

\iffalse
Î³ â‰… Î³Â² in âˆ\_(âˆ-Cat)â„Sâ‚€

I â‰… IÂ² in âˆ\_(âˆ-Grpd)/Sâ‚€

A-infinity operad / A-infinity operoid
E-infinity operad / E-infinity operoid

Grouplike A-infinity operad with ... / Groupal A-infinity operoid
Grouplike E-infinity operad / Groupal E-infinity operoid

Monoid / Category
Abelian Monoid / Strict Twocategory

Group / Groupoid
Abelian Group / Strict Twogroupoid
\fi

\iffalse
Chain complex, which I here refer to as a \href{}{flat} complex.
\fi

\iffalse
What is the relationship between algebras for an A-type operad in algebras for an ...
What is the relationship between algebras for an E-type operad in algebras for an ...
\fi

\iffalse
A-spectrum
E-spectrum
\fi

\newpage
\section{Introduction to \texttt{Lean 4}}

The main way to tell Lean 4 what something means is with $\texttt{def}$, which defines a term in \href{https://leanprover.github.io/theorem_proving_in_lean/dependent_type_theory.html}{dependent type theory}. Much in the same way as other computer languages, we then supply the type of the term (e.g. $\texttt{Int}$ for integer), followed by the formula itself:

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def zero : Nat := 0

\end{minted}
\end{tcolorbox}
\end{center}

Here we have introduced a natural number $\texttt{n}$ using the type $\texttt{Nat}$ that comes with Lean 4.\\

As a beginner, it's normal to take some time to get comfortable with Lean and formal proof systems. It's a journey that requires practice and patience. Lean has an \href{https://leanprover.zulipchat.com}{active community} that provides support and resources to help you along the way.\\

Constituents of $\texttt{x, y : X}$ of types $\texttt{X}$ can also stand to be equal or unequal, written $\texttt{x = y}$, and it is the properties of equality which in addition to the dependent type theory make a type behave like a set. Equality satisfies the three properties of an equivalence relation, which we cover presently. Consider first the reflexivity property of equality:\\

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def reflexivity {X : Type} {x : X} : x = x := Eq.refl x

\end{minted}
\end{tcolorbox}
\end{center}

This command defines a function called reflexivity that proves the reflexivity property of equality. The function takes two type parameters: $\texttt{X}$ represents the type of the elements being compared, and $\texttt{x}$ represents an element of type $\texttt{X}$. It also takes an argument Ï‰ which is a proof that $\texttt{x}$ is equal to itself ($\texttt{x = x}$). The function body states that the result of $\texttt{reflexivity}$ is the proof Ï‰ itself using the $\texttt{Eq.refl}$ constructor, which indicates that $\texttt{x}$  is equal to itself.

In $\texttt{Lean 4}$, $\{\texttt{x : X}\}$ represents an implicit argument, where Lean will attempt to infer the value of $\texttt{x}$ based on the context. $\texttt{(x : X)}$ represents an explicit argument, requiring the value of $\texttt{x}$ to be provided explicitly when using the function or definition.

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def symmetry {X : Type} {x : X} {y : X}  (p : x = y) := Eq.symm p

\end{minted}
\end{tcolorbox}
\end{center}

This command defines a function called symmetry that proves the symmetry property of equality. It takes three type parameters: $\texttt{X}$ represents the type of the elements being compared, and $\texttt{x}$ and $\texttt{y}$ represent elements of type $\texttt{X}$. The function also takes an argument Ï‰ which is a proof that $\texttt{x}$ is equal to $\texttt{y}$ ($\texttt{x=y}$). The function body states that the result of $\texttt{symmetry}$ is the proof Ï‰ itself using the $\texttt{Eq.symm}$ constructor, which allows you to reverse an equality proof.

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def transitivity {X : Type} {x : X} {y : X} {z : X} (p : x = y) (q : y = z) := Eq.trans p q

\end{minted}
\end{tcolorbox}
\end{center}

This command defines a function called transitivity that proves the transitivity property of equality. It takes four type parameters: $\texttt{X}$ represents the type of the elements being compared, and $\texttt{x}$, $\texttt{y}$, and $\texttt{z}$ represent elements of type $\texttt{X}$. The function also takes two arguments $\texttt{p}$ and $\texttt{q}$. $\texttt{p}$ is a proof that $\texttt{x}$ is equal to $\texttt{y}$ ($\texttt{x = y}$), and $\texttt{q}$ is a proof that $\texttt{y}$ is equal to $\texttt{z}$ ($\texttt{y = z}$). The function body states that the result of transitivity is the proof of the composition of Ï‰ and $\texttt{q}$ using the $\texttt{Eq.trans}$ constructor, which allows you to combine two equality proofs to obtain a new one.\\

These $\texttt{Lean}$ commands define functions that prove fundamental properties of equality: reflexivity (every element is equal to itself), symmetry (equality is symmetric), and transitivity (equality is transitive). These properties are essential for reasoning about equality in mathematics and formal proofs.\\

We must also require that functions satisfy extensionality:

%LEAN: some essential features of equality
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def extensionality (f g : X â†’ Y) (p : (x:X) â†’ f x = g x) : f = g := funext p

\end{minted}
\end{tcolorbox}
\end{center}

Extensionality, a key characteristic of sets and types, asserts that functions which are equal on all values are themselves equal, and it is featured prominently in what is perhaps the most well known mathematical foundations of \href{https://encyclopediaofmath.org/wiki/ZFC}{ZFC}.\\

There are several other features of equality with respect to functions which we should be aware of:

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def equal_arguments {X : Type} {Y : Type} {a : X} {b : X} (f : X â†’ Y) (p : a = b) : f a = f b := congrArg f p

def equal_functions {X : Type} {Y : Type} {fâ‚ : X â†’ Y} {fâ‚‚ : X â†’ Y} (p : fâ‚ = fâ‚‚) (x : X) : fâ‚ x = fâ‚‚ x := congrFun Ï‰ x

def pairwise {A : Type} {B : Type} (aâ‚ : A) (aâ‚‚ : A) (bâ‚ : B) (bâ‚‚ : B) (p : aâ‚ = aâ‚‚) (q : bâ‚ = bâ‚‚) : (aâ‚,bâ‚)=(aâ‚‚,bâ‚‚) := (congr ((congrArg Prod.mk) p) q)

\end{minted}
\end{tcolorbox}
\end{center}

Here are some introductions to Lean 4 and Mathlib 4:

\begin{enumerate}
\item The tutorial \href{https://leanprover.github.io/theorem_proving_in_lean4/}{here} gives an introduction to using the dependent type theory in Lean.
\item 
\end{enumerate}





\part{BASED âˆ-GROUPOIDS}

In this first section we prove the standard Whitehead theorem.\\


\chapter{Chapter 1: âˆ\texttt{-Grpdâ‚‹â‚}}

\begin{definition}[CW-complex]
Given a well order Ï‰, a CW-complex ...
\end{definition}



\noindent\textcolor{Red}{\rule{16cm}{1mm}}
\begin{center}
\texttt{Implementation Progress}
\end{center}
\noindent\textcolor{Red}{\rule{16cm}{1mm}}


%LEAN: CWComplex
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

/-- A relative CW-complex contains an expanding sequence of subspaces `sk i`
(called the `i`-skeleta) for `i â‰¥ -1`, where `sk (-1)` is an arbitrary topological space,
isomorphic to `A`, and each `sk (n+1)` is obtained from `sk n` by attaching (n+1)-disks. -/
structure RelativeCWComplex (A : TopCat) where
  /-- Skeleta -/
  sk : â„¤ â†’ TopCat
  /-- A is isomorphic to the (-1)-skeleton. -/
  iso_sk_neg_one : A â‰… sk (-1)
  /-- The (n+1)-skeleton is obtained from the n-skeleton by attaching (n+1)-disks. -/
  attach_cells : (n : â„¤) â†’ CWComplex.AttachCells (sk n) (sk (n + 1)) n

/-- A CW-complex is a relative CW-complex whose (-1)-skeleton is empty. -/
abbrev CWComplex := RelativeCWComplex (TopCat.of Empty)

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: CWComplexCat (topology)
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

/-- The topology on a relative CW-complex -/
def toTopCat {A : TopCat} (X : RelativeCWComplex A) : TopCat :=
  Limits.colimit (colimitDiagram X)

instance : Coe CWComplex TopCat where coe X := toTopCat X

\end{minted}
\end{tcolorbox}
\end{center}


%LEAN: CWComplexCat (category of CW complexes)
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def IsCWComplex (X : TopCat) : Prop := âˆƒ Y : CWComplex, Nonempty (â†‘Y â‰… X)

def CWComplexCat := FullSubcategory IsCWComplex

\end{minted}
\end{tcolorbox}
\end{center}



\noindent\textcolor{Red}{\rule{16cm}{1mm}}
\begin{center}
\texttt{Writing Progress}
\end{center}
\noindent\textcolor{Red}{\rule{16cm}{1mm}}



Here we define CW-complexes, as well as relative CW-complexes, and also the derived categories D(âˆ-Grpdâ‚€) of connected based âˆ-groupoids and D(âˆ-Grpdâ‚€/Gâ‚€), made from CW-complexes.\\

\section{D(âˆ-Grpdâ‚‹â‚)}

{\footnotesize
\begin{center}
\begin{tabular}{|| l || l || l || l ||} 
\hline
$\texttt{Symbol}$ & $\texttt{Unicode}$ & \texttt{VSCode shortcut} & $\texttt{Use}$\\
\hline
\multicolumn{4}{||c||}{\texttt{Lean's Kernel}} \\
\hline
Ã— & 2A2F & \backslash\texttt{times} & Product of types\\
\hline
â†’ & 2192 & \backslash\texttt{rightarrow}  & Hom of types\\
\hline
âŠ£ & 22A3 & \backslash\texttt{dashv}  & The condition that two functors are adjoint \\
\hline
?,Â¿ & 003F, 00BF & ?,\backslash\texttt{?}  & The corresponding (co)monad of an adjunction\\
\hline
âˆ¼ & 223C & \backslash\texttt{sim} & Homotopies \\
\hline
\end{tabular}
\end{center}}

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

\end{minted}
\end{tcolorbox}
\end{center}

\section{D(âˆ-Grpdâ‚€/Xâ‚€)}

The derived category of BASED âˆ-groupoids over Xâ‚€. \\

\section{Î© : âˆ-Grpdâ‚€ â­¢ âˆ-Grpd}



\section{Î£ : âˆ-Grpdâ‚€ â­¢ âˆ-Grpdâ‚€} 

The based suspension functor

\section{Ï‰ f : âˆ-Grpd/Dâ‚€ â­¢ âˆ-Grpd/Câ‚€}

The homotopy fiber

\section{Ïƒ f : âˆ-Grpdâ‚€/Câ‚€ â­¢ âˆ-Grpdâ‚€/Dâ‚€}

Based homotopy pushout

\section{Ï€â‚™ : âˆ-Grpdâ‚€ â­¢ Set}

The connected components functors

\iffalse
https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Homotopy/Basic.html
\fi



\chapter{Chapter 2: The Whitehead Theorem}





The proof of the Whitehead theorem divides into REP (replacement for based âˆ-groupoids X : âˆ-Grpdâ‚‹â‚) and HEP (the homotopy extension property for weak equivalent maps of based âˆ-groupoids). The replacement functor âˆ$\texttt{-Grpd}$â‚€ can be constructed using globular sets.\\

Globular sets are not a rich enough invariant for homotopy, but maps of globular sets bear a criticall difference because of 

\begin{center}
\texttt{âˆ€(E:D(âˆ-Grpdâ‚€)),âˆ€(B:D(âˆ-Grpdâ‚€)),âˆ€(f:E â­¢ B),âˆ€(G:E â­¢ B),(âˆ€(n:Nat),(Ï€â‚€ F = Ï€â‚€ G)) â­¢ F = G}
\end{center}

\section{Globular Sets}

The globe category ğ”¾ is the category

\begin{center}
\includegraphics[scale=0.5]{globecat.png}
\end{center}

\href{https://ncatlab.org/nlab/show/globular+set}{Globular sets} are functors from the opposite category of the globe category ğ”¾ into the category of sets, and maps of globular sets are natural transformations between them.\\

In this chapter we prove the following (which we have called Whitehead Theorem (c)): âˆ€(E:D(âˆ-Grpdâ‚€)),âˆ€(B:D(âˆ-Grpdâ‚€)),âˆ€(f:E â­¢ B),âˆ€(G:E â­¢ B),(âˆ€(n:Nat),(Ï€â‚™ F = Ï€â‚™ G)) â­¢ F = G, where Ï€â‚™ is notation for Ï€ n.\\

This can be shown using CW-replacement and induction on n. Fibrant replacement of an object X entails replacing an object in âˆ-Grpdâ‚€ with a CW-object (an object made by successively glueing in higher and higher simplices along their boundaries obtaining a sequence Xâ‚™). Given an equality Ï€${}_{n+1}(f) = $Ï€${}_{n+1}(g)$ and a homotopy equivalence hâ‚™ : Î”Â¹ Ã— Xâ‚™ â­¢ Y between $f|_{X_n}, g|_{X_n}$ : Xâ‚™ â­¢ Y, we construct an extension of the homotopy equivalence Î”Â¹ Ã— $X_{n+1}$ â­¢ Y.\\

\iffalse
Can the attaching map be 
\fi

{\bf Spheres and balls} Next we turn to defining spheres and balls:

{
\footnotesize
\begin{center}
\begin{tabular}{||l || l || l ||} 
 \hline
  & \multicolumn{2}{||c||}{\texttt{Spheres and Balls}} \\
 \hline
 Name of the $\texttt{X}$ value & \texttt{âˆ‚X â‰… Sâ¿} & \texttt{X â‰… Dâ¿} \\
 \hline
 \hline
 p-norm unit ball for p = 1 & âˆ‚B(1,n) & B(1,n) \\
 \hline
 p-norm unit ball for 1 < p < 2 & âˆ‚B(p,n) & B(p,n) \\
 \hline
 p-norm unit ball for p = 2 & âˆ‚B(2,n) & B(2,n) \\
 \hline
 p-norm unit ball for 2 < p < âˆ & âˆ‚B(p,n) & B(p,n) \\
 \hline
 p-norm unit ball for p = âˆ & âˆ‚B(âˆ,n) & B(âˆ,n) \\
 \hline
 The n-simplex & âˆ‚Î”â¿ & Î”â¿ \\
 \hline
 \hline
\end{tabular}
\end{center}
}

While each of the above unit balls are homeomorphic, so that one has a choice of $p$-norm, the unit balls in [â„•,â„] for different norms are not homeomorphic. Here are two lemmas we have for the 2-norm and âˆ-norm unit balls in [â„•,â„]:

\begin{theorem}
$\texttt{I Ã— B â‰… B}$, where B is the unit ball in lâ‚‚ under the 2-norm.
\end{theorem}

\begin{proof}
...
\end{proof}

\begin{theorem}
$\texttt{I Ã— [â„•,I] â‰… [â„•,I]}$, where B is the unit ball in lâ‚‚ under the 2-norm.
\end{theorem}

\begin{proof}
...
\end{proof}


\begin{definition}[(a)]
...
\end{definition}

\iffalse
\begin{definition}
Define a function d${}^{(n_1,...,n_k)} : $ D${}^{n_1}$ Ã— $\cdots$ Ã— D${}^{n_k}$ â­¢ D${}^{n_1 + \cdots + n_k}$ sending $(x_1,...,x_k)$...
\end{definition}
\fi

\begin{theorem}
iÂ¹ : Sâ° â­¢ DÂ¹ 
\end{theorem}

\begin{theorem}
Dâ¿ Ã— DÂ¹ â­¢ Dâ¿âºÂ¹
\end{theorem}

\begin{definition}
Dâ¿ â­¢ Dáµ
\end{definition}


\begin{theorem}
Fix n : â„• and let âˆ‚â¿ : Sâ¿ â­¢ Dâ¿âºÂ¹ be the inclusion. The pushout of the following diagram is isomorphic to Sâ¿âºÂ¹:
\begin{center}
\includegraphics[scale=0.5]{pushout.png}
\end{center}
\end{theorem}

\begin{proof}

\end{proof}


\begin{theorem}
Define a function ||-||${}_{2}$ : Dâ¿ â­¢ I sending (xâ‚,...,xâ‚™) to $\sqrt{\sum_{i = 1}^n x_i^2}$, and write ||-||${}_{2}$
\end{theorem}

\begin{proof}
...
\end{proof}


\section{HEP for based connected âˆ-groupoids}

In this section we prove the homotopy extension property for based âˆ-groupoids, which we model as CW-complexes.

{\bf Jar filling} Next we turn to defining `jar shapes' $\texttt{Jâ¿}$, which include into $\texttt{Dâ¿ Ã— I}$ $\texttt{iâ‚™ : Jâ¿ â­¢ Dâ¿ Ã— I}$, after which we `fill' them (i.e. demonstrate that any continuous map f : Jâ¿ â­¢ X extends to a continuous map g : Dâ¿ Ã— I â­¢ X).\\

\begin{definition}
We define the n-jar $\texttt{Jâ‚™ := pushout (Sâ¿ Ã— dâ‚€) âˆ‚Dâ¿}$, where $\texttt{dâ‚€ : * â­¢ I}$ sends the unique point $\texttt{* : *}$ to $\texttt{0}$. There is a continuous function $\texttt{jâ‚™}$ from $\texttt{Jâ‚™}$ to $\texttt{Dâ¿}$ arising from the functions $\texttt{âˆ‚Dâ¿ Ã— I : Sâ¿ Ã— I â­¢ Dâ¿ Ã— I}$ and $\texttt{}$
\end{definition}

$\texttt{jâ‚™}$ in the above is injective. In the case where $\texttt{n = 3}$ we can depict it as the inclusion of the `empty jar shape' into the `filled jar shape' of $\texttt{DÂ² Ã— I}$. `Jar filling' then asserts that any continuous function f : Jâ‚™ â­¢ X extends to a continuous function g : DÂ² Ã— I â­¢ X:

\begin{theorem}[Jar filling]
$\texttt{âˆ€(f : Jâ‚™ â­¢ X),âˆƒ(g : Dâ¿ Ã— I),g â€¢ jâ‚™ = f}$.
\end{theorem}

The first approach I cover here involves `shining a light ray down from above the jar', i.e. projection. This divides into two steps, where in the first we define the projection onto the sides and bottom (seperately), and in the second we show that these continuous functions match on Sâ¿â»Â¹ and that they assemble into a continuous function projâ‚™ from Dâ¿ Ã— I to Jâ‚™.\\

\begin{theorem}
There is a continuous function $\texttt{proj}_{\texttt{n}} : Dâ¿ Ã— I \rightarrow Jâ‚™$ such that .
\end{theorem}

After this, we show that $\texttt{projâ‚™ â€¢ jâ‚™ = }1_{Jâ‚™}$.\\




\iffalse
In what follows, it is possible to use CW-complexes instead of CW-complexes. This reflects how the argument makes no use of the stronger condition associated to the CW-complexes that cells be attached in order of nondecreasing dimension.
\fi

{\bf Change of Base} Change of base demonstrates that Ï€â‚™(X,x) is isomorphic to Ï€â‚™(X,y) for a connected CW-complex X and two different points x and y in X given a path between them. This isomorphism depends on the choice of path.

\begin{definition}
Let X be a connected CW-complex and let n : Nat be a natural number. The transport function $\texttt{trans\ n\ X : (f : [I,X])  â†’ Ï€â‚™ (X,ev f 0) â­¢ Ï€â‚™ (X, ev f 1)}$ ...
\end{definition}

\begin{theorem}
Let Xâ‚‹â‚ be a connected CW-complex and let f : I â­¢ Xâ‚‹â‚ be a path, so that $\texttt{(trans\ n Xâ‚‹â‚ fâ»Â¹) â€¢ (trans\ n Xâ‚‹â‚ f)}$ has type $\texttt{Ï€â‚™ (f 0) â­¢ Ï€â‚™ (f 0)}$. Then
\begin{center}
$\texttt{(trans\ n Xâ‚‹â‚ fâ»Â¹) â€¢ (trans\ n Xâ‚‹â‚ f) = 1\_(Ï€â‚™ (f 0))}$
\end{center}
\end{theorem}

\begin{proof}
...
\end{proof}

The proof in the above can be depicted like so, as a `painting with two concentric frames':

\begin{center}
\includegraphics[scale=0.5]{windowframe.png}
\end{center}

that the based CW-complexes (X,x) and (X,y) are 

\begin{theorem}

\end{theorem}

\begin{proof}
...
\end{proof}

\begin{center}
\includegraphics[width=3.5cm,height=5cm]{proj.png}
\end{center}

 

 \iffalse
- Base change for based connected CW-complexes
- pushout âˆ‚Dâ¿ âˆ‚Dâ¿ â‰… Sâ¿, where âˆ‚Dâ¿ : Sâ¿ â­¢ Dâ¿
- The unit balls in â„â¿ under the p norm are homotopic via ...
- The unit balls ...
- Lemma: Given Ï† : Dâ¿ â­¢ X and f, g : X â­¢ Y such that f â€¢ Ï† â€¢ âˆ‚Dâ¿ = g â€¢ Ï† â€¢ âˆ‚Dâ¿,
- HEP (the homotopy extension property) given spaces X, Y, and continuous maps Î± : Sâ¿ â­¢ X, f : pushout âˆ‚Dâ¿âºÂ¹ Î± â­¢ Y, g : pushout âˆ‚Dâ¿âºÂ¹ Î± â­¢ Y, H : homotopy (f â€¢ ?, g â€¢ ?), then f and g are homotopic.  
- REP (the replacement property) given a space X, there is a CW-complex Y and a continuous map f : Y â­¢ X which is a weak equivalence.
- (The Whitehead theorem) a weak equivalence of continuous functions f, g : X â­¢ Y with X a CW-complex is a homotopy equivalence.
- Functor extensionality
- Jar filling for Dâ¿ and Sâ¿
- Proving that the unit ball B in lâ‚‚(â„) is homeomorphic to B Ã— BÂ¹(â„)
\fi

the homotopy extension property

\begin{theorem}[HEP] given spaces X, Y, and continuous maps Î± : Sâ¿ â­¢ X, f : pushout âˆ‚Dâ¿âºÂ¹ Î± â­¢ Y, g : pushout âˆ‚Dâ¿âºÂ¹ Î± â­¢ Y, H : homotopy (f â€¢ ?, g â€¢ ?), then f and g are homotopic.  
\end{theorem}

\begin{proof}

\end{proof}

...\\

\section{REP for based connected âˆ-groupoids}

In this section we use the notion of globular sets to replace a topological space with a CW-complex. Together with HEP (homotopy extension), this will complete the proof of the Whitehead theorem.\\

In fact, we will construct more than this: an adjunction F âŠ£ G between globular sets and topological spaces. For this we continue with the construction of G:\\

\iffalse We want to use their hom! \fi

\begin{definition}[The object component of the functor from topological spaces to globular sets]
Fix a topological space X, and to form the object component of G.obj X, Gobj X : TGlb, we define (Gobj X).obj n to Top.Hom Dâ¿ X. Defining Gobj X on morphisms is not much more difficult, and involves composition Ïƒâ‚™, Ï„â‚™ : Dâ¿ â­¢ Dâ¿âºÂ¹.
\end{definition}

\begin{definition}[The morphism component of the functor from topological spaces to globular sets]
...
\end{definition}

\begin{definition}[Proving the identity for the functor from topological spaces to globular sets]
...
\end{definition}

\begin{definition}[Proving the compositionality law for the functor from topological spaces to globular sets]
...
\end{definition}

To construct F, we first construct a term of the CW-complex structure built from a globular set Î¦.\\

\iffalse
Later: locales...
\fi

\section{The Whitehead theorem}

Here we show the Whitehead theorem using the homotopy extension property and replacement.

\iffalse
https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Homotopy/HomotopyGroup.html
\fi

\iffalse
In proving the Whitehead theorem formally, \textit{we make use of a line} as well as, in essence, the structure of a \textit{groupoid} $\texttt{G}_{\texttt{X}}$ where $\texttt{Hom}{}_{\texttt{G}}\texttt{(x,x)}$ is taken to be Ï€â‚™(X,x). This interesting feature of the proof relates to the other two Whitehead theorems featuring categories Î âƒ—â‚™ and groupoids Î â‚™.\\
\fi


\chapter{Chapter 3: The Category of Maps}

In this section I cover the category of maps $\texttt{Map C}$ in a category $\texttt{C}$. After this I inductively form $\texttt{â–¡â¿âºÂ¹ C}$ as $\texttt{Map (â–¡â¿ C)}$ and $\texttt{â–¡â±â¿á¶  C}$ as the colimit of $\texttt{â–¡â¿ C}$.\\




\part{âˆ-GROUPOIDS}

The Whitehead theorem is about the ways that spheres get trapped in spaces (higher homotopy groups), and the last section established how these higher homotopy groups relate to maps in the homotopy category of based CW-complexes.\\


\chapter{Chapter 9: âˆ\texttt{-Grpd}}


\section{Î©âƒ¡}

Our choice of symbols refects our choice of three variations of the Whitehead theorem and three Puppe sequences. Î©âƒ¡, the analogue of loop space, is the internal hom functor [I,-] : âˆ-Grpd â­¢ âˆ-Grpd. This is not hard to construct, with the main lemma being that the path space of a quasicategory has the quasicategory lifting conditon.\\

We will be interested in one formal model of D(âˆ-Cat) which consists of formal compositions fâ‚ â€¢ gâ‚ â€¢ fâ‚‚ â€¢ gâ‚‚ â€¢ â‹¯ â€¢ fâ‚™ â€¢ gâ‚™, where gâ‚™ $: Dom(f{}_{n+1}) $â­¢ ??? is a weak equivalence, and something similar for D(âˆ-Cat). However, it is still vital to have the replacement functor $\texttt{repl}$, which ensures the Whitehead theorem for particular âˆ-categories which are constructed out of attaching maps.\\


\section{Ï‰âƒ¡}

Î©âƒ— is to internal categories as Ï‰âƒ¡ is to internal G-actions. It is also called directed homotopy pullback. These functors will later be used to produce functors Pâƒ¡ : D(âˆ-Grpd) â­¢ InternalCategory D(âˆ-Grpd) and pâƒ¡ : D(âˆ-Grpdâ„C) â­¢ InternalPresheaf (Pâƒ¡ G) D(âˆ-Grpdâ„G).\\


\section{Î â‚™}






\chapter{Chapter 10: The Whitehead Theorem for âˆ-Groupoids}




\section{Cubical Complexes}

...\\

\iffalse
In this chapter, we take on the objective of Whitehead theorem (a), out of which we will prove the other more concrete Whitehead theorems:\\

\begin{center} âˆ€(E:D(âˆ-Grpd)),âˆ€(B:D(âˆ-Grpd)),âˆ€(F:E â­¢ B),âˆ€(G:E â­¢ B),(âˆ€(n:Nat),(Î â‚™ F = Î â‚™ G)) â­¢ F = G
\end{center}

We can attempt to form a slightly different category, much like the above, called ğ““(âˆ-Cat), at first, and in a formal way, so as to create a category whose object component ğ““(âˆ-Cat).Î± matches the object component âˆ-Cat.Î± while featuring the above theorem in a formal way. However, with this as our model of D(âˆ-Cat), we may then also be interested in the establishment of a model in which the Whitehead theorem is demonstrated, with the main idea being to prove two complementary concepts:

\begin{enumerate}
\item (REP) Establish ``weak equivalent fibrant replacement" R : âˆ-Cat.Î± â­¢ âˆ-Cat.Î± (.Î± gives the object component in Mathlib's category theory library), analogous to CW-complex replacement in Whitehead's original paper. It's especially nice if R forms the object component of a functor F : âˆ-Cat â­¢ âˆ-Cat. D(F) : D(âˆ-Cat) â­¢ D(âˆ-Cat) should be a categorical equivalence, and that is what we will do.
\item (HEP) For the object R X, demonstrate that any F,G : (R X) â­¢ Y such that âˆ€(n:Nat),(Î âƒ—â‚™ F = Î âƒ—â‚™ G), there is a directed homotopy equivalence between F and G. Note that ``directed homotopy equivalence" consists of a composible sequence of simple directed homotopies Háµ¢ : Î”Â¹ Ã— (R X) â­¢ Y, 1 â‰¤ i â‰¤ n, with even Háµ¢ running reverse to the odd Háµ¢.
\end{enumerate} 

Both of these will use induction on Lean's $\texttt{Nat}$. The first of these could be called a REP (for REplacement Property, but this isn't usual terminology), and the second typically uses induction and a HEP (Homotopy Extension Property). Our REPa will consist of objects made out of particular kinds of pushouts called attaching maps, and can be made functorial. Proving the HEPa can be done by well-order induction on the attaching maps present in our choice of R, thereby reducing to the case of extending a homotopy along a single attachment.\\

Our HEPa (directed box filling) is similar to the HEP shown in Whitehead's original paper, and to the approach detailed in Hatcher's textbook, though no doubt modified to suit our two goals:

\begin{enumerate}[(I)]
\item The analogue of the Puppe sequence on the front cover needs to hold.
\item The first Whitehead theorem on the front cover needs to hold.
\end{enumerate}

These two considerations determine our choice of Î âƒ—â‚™, Î©âƒ—, and Ï‰âƒ—. We take Î©âƒ— to be (simply) the internal hom functor [Î”Â¹,-] (which requires showing that Î©âƒ—X has the inner-horn filling condition). Ï‰âƒ— is then defined as a certain pullback of Î©âƒ—, and Î âƒ—â‚™ is designed to produce a Puppe sequence with a meaningful notion of exactness by which we can demonstrate the goal of recognition theorems (i) and (ii). Specifically, it makes sense to use cubes in our definition of Î âƒ—â‚™ because of how they are representing objects of Î©âƒ—â¿. Meanwhile, it is also clear that the quotient producing Î âƒ—â‚™ is subtle in exactly how it requires fixing the endpoints of a sequence of alternating directed homotopies. We will define Î âƒ—â‚™'s by identifying those objects x, y: Î©âƒ—â¿ X which are homotopic by a homotopy which restricts to a constant along the face maps fáµ¢ : Î©âƒ—${}^{n-1}$ X â­¢ Î©âƒ—${}^{n-1}$ X (which correspond to Maps (n,b), where b : Bool).\\

Imagine for a moment the picture of a square shaped cusion; we might make such a cusion by first soeing together 6 squares of cloth and filling it with material, then "soeing the walls down to a square". Here we go with this:

\begin{enumerate}
\item Define a n-cubical cusion using the boundary of an n-1 cube times Î”Â¹, i.e. the quotient of (Î”Â¹)${}^{n-1}$ Ã— Î”Â¹ by an equivalence relation, but we have to start our model somewhere), or perhaps more easily the pushout of f : Î”Â¹ Ã— (âˆ‚((Î”Â¹)â¿)) â­¢ (Î”Â¹)${}^{n+1}$ by the projection map Î”Â¹ Ã— (âˆ‚((Î”Â¹)â¿)) â­¢ âˆ‚((Î”Â¹)â¿)
\item Define a simplicial cusion using the boundary of an n-1 simplex times Î”Â¹, i.e. the quotient of (Î”Â¹) by an equivalence relation, or perhaps more easily the pushout of f : Î”Â¹ Ã— (âˆ‚(Î”â¿)) â­¢ (Î”Â¹) Ã— Î”â¿ by the projection map Î”Â¹ Ã— (âˆ‚((Î”Â¹)â¿)) â­¢ âˆ‚(Î”â¿)
\end{enumerate}

The boundary of a cusion is a pouch, isomorphic to a pushout of two cubes glued together at their boundaries:

\begin{enumerate}
\item Define a n-cubical pouch as the pushout of two boundary maps âˆ‚((Î”Â¹)â¿) â­¢ (Î”Â¹)â¿
\item Define a simplicial pouch as the pushout of two boundary maps âˆ‚(Î”â¿) â­¢ Î”â¿
\end{enumerate}

Notice that paths in Î©âƒ—â¿X produce paths in Î©âƒ—${}^{n-1}$X in as many ways as there are face maps (Î”Â¹)${}^{n-1}$ â­¢ Î”Â¹${}^{n}$, these could be called restrictions and are no doubt related to the pouches and cusions we just defined. The cartesian closed structure on simplicial sets with the lifting condition clarifies the relationship between the two available definitions of Î âƒ—â‚™:

\begin{enumerate}
\item Homotopies of maps from a cube which are constant on the boundary
\item Paths of maps in Î©âƒ—${}^{n-1}$X which produce constant maps under the mentioned restritions.
\item Maps from a pouch mod an equivalence relation (really we phrase this as a pushout!), namely the equivalence relation in which any two maps from a pouch that extend to maps from a cusion are identified.
\end{enumerate}

After we construct Î âƒ—â‚™ in the first section, we will be in a place to demonstrate that the natural transformation $\texttt{weak\_equivalence : repl â­¢ (ğŸ™ }$âˆ$\texttt{-Cat)}$ consists of weak equivalences (a fact which we call REP, which is short for REplacement Principal). This is covered in the section titled REP, which also constructs $\texttt{repl}$ and $\texttt{weak\_requivalence}$.\\

In sum, the goal of the present chapter is to use similar insights to the proof of the Whitehead theorem featured Hatcher's textbook to prove Wa and Pa for the model of quasicategories, using Mathlib's predefined horns and simplices in its simplicial sets section. The main difference is that our work must take care to respect the directed nature of quasicategories.\\
\fi

\iffalse
In the future, we intend to add important aspects of the bigger picture besides those which directly establish REP and HEP in the sections below. These are important considerations in ensuring usability. Three different model structures on âˆ-Cat ensue from the six definitions below, which are contained in Lurie's ``Higher Topos Theory" on page 53, and which are due to Joyal:

\begin{definition} A morphism $\texttt{f : X â­¢ S}$ of simplicial sets is
\begin{enumerate}
\item A left fibration if f has the right lifting property with respect to all
horn inclusions Î›ni âŠ† âˆ†n, 0 â‰¤ i < n.
\item A right fibration if f has the right lifting property with respect to all
horn inclusions Î›ni âŠ† âˆ†n, 0 < i â‰¤ n.
\item An inner fibration if f has the right lifting property with respect to all
horn inclusions Î›ni âŠ† âˆ†n, 0 < i < n.
\end{enumerate}
A morphism of simplicial sets $\texttt{i : A â­¢ B}$ is
\begin{enumerate}
\item left anodyne if $\texttt{i}$ has the left lifting property with respect to all left fibrations.
\item right anodyne if $\texttt{i}$ has the left lifting property with respect to all right fibrations.
\item inner anodyne if $\texttt{i}$ has the left lifting property with respect to all inner fibrations.
\end{enumerate}
\end{definition}
\fi

\begin{enumerate}
\item Defining $\texttt{repl}$
\item 
\end{enumerate}



\section{REP}

We have divided the work of proving Whitehead theorem (a) into two steps: REP and HEP. In this section, we construct a functor $\texttt{repl : }$âˆ$\texttt{-Cat â­¢ }$âˆ$\texttt{-Cat}$ along with a natural transformation $\texttt{weak\_equivalence : repl â­¢ (ğŸ™ }$âˆ$\texttt{-Cat)}$. To construct $\texttt{repl}$ 




\section{HEP}

Consider the context of , supposing that we have constructed a homotopy ... This gives a picture that is a bit like ``filling up a jar``: a homotopy h : of f, g : âˆ‚Î”Â² â­¢ Y, along with the value of g on Î”Â², produces a ``jar" shape in Y, which can be ``filled up" to produce a homotopy h : Î”Â¹ Ã— Î”Â² â­¢ Y. This is easier for simplicial-based approaches than for point-set topological approaches, the latter of which needs extra steps that deform a map into a cellular map.\\

This construction, in the case of point set topology, often involves first deforming maps so as to be cellular; however our analogue of CW complexes allows us to skip this step.\\

This construction (HEP for quasicategories) may even be equivalent to the quasicategory lifting condition if we are lucky. It is also the main technical device allowing for our concrete choice of model (quasicategories).\\

In this section, we demonstrate this extension property and use it to conclude the Whitehead theorem for âˆ-categories stated above.\\

\begin{center}
\includegraphics[width=0.5\textwidth]{HEP.png}
\end{center}

{\bf Prism Filling (PF)} Let Y be a quasicategory, and let f, g : âˆ‚Î”â¿ â­¢ Y. A homotopy h : âˆ‚Î”â¿ Ã— Î”Â¹ â­¢ Y between f, g : âˆ‚Î”â¿ â­¢ Y extends to a map H : Î”â¿ Ã— Î”Â¹ â­¢ Y; this follows from the condition that Y be a quasicategory. H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary. Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

Directed prism filling may combine fruitfully with the yoneda lemma and/or the fact that simplicial sets are determined by the sets [Î”â¿,X] along with combinatorial information (face and degeneracy maps).

{\bf Decomposing Î”â¿ Ã— Î”Â¹ into a colimit involving n+1 Î”${}^{n+1}$'s} ...

\begin{center}
\includegraphics[width=300pt]{prismfilling.png}
\end{center}

In the above, it may be easier if we make use of sub-simplicial sets and prove the theorem using that colimit applied to a natural isomorphism of diagrams products an isomorphism.\\

The decomposition 

A definition of Î âƒ—â‚™ which is consistent with our goals of Wa and Pa is one as a certain pushout involving (Î©âƒ—â¿ X)-- one which amounts to taking an equivalence relation by paths in Î©âƒ—â¿ X which restrict to constant paths along the face maps fáµ¢ : Î©âƒ—${}^{n-1}$ X â­¢ Î©âƒ—â¿ X. Here, Î©âƒ— is easy to define in the model of quasi-categories, and it amounts . Besides fullfilling our goal of the first Whitehead theorem and puppe sequence, this definition of Î âƒ—â‚™ strikes me as elegant because it uses all of the ways for Î©âƒ—â¿ X to map into Î©âƒ—${}^{n+1}$ X.\\

The next symbols in the project's ``periodic table" that we construct, after Î©âƒ— and Î âƒ—â‚™, will be Bâƒ— and Eâƒ—, which we feature in the chapter on Puppe sequence (a).\\

A useful thing for us to construct first is the boundary of a product of Î”Â¹'s and the boundary of a directed simplex. We might even like to expand on this later, but for now just consider for a moment how each might be made out of a glueing construction involving face maps.\\

Even though the Î âƒ—â‚™'s can be defined using Î©âƒ—â¿ X and various face maps f$\_(n,b)$ : Î©âƒ—${}^{n-1}$ X â­¢ Î©âƒ—${}^{n}$ X for $b : \{ 0, 1 \}$, it may be nice to have this as a result, with the definition one featuring two cubes glued together along their boundary.\\

This means that we want directed box filling in addition to directed prism filling (but which also uses directed prism filling in its proof).

{\bf Box Filling (BF)} Let Y be a quasicategory, and let f, g : âˆ‚Î”â¿ â­¢ Y. A homotopy h : âˆ‚Î”â¿ Ã— Î”Â¹ â­¢ Y between f, g : âˆ‚Î”â¿ â­¢ Y extends to a map H : Î”â¿ Ã— Î”Â¹ â­¢ Y; this follows from the condition that Y be a quasicategory. H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary. Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

This goes hand-in-hand with a definition of Î âƒ—â‚™ which suits (I) and (II) in the introduction to chapter (3). If we make sure to prove lemmas... 

The box filling and prism filling HEPs can be extended to the case of attaching all cells of a particular fixed dimension and as indexed by simplicial set arising from a set (or Lean 4 $\texttt{Type}$). That is, we might like to extend Ã— $()$ (or possibly somehow a $\texttt{Set}$ as well), and that we may find an interest in the following two definitions of Î âƒ—â‚™, which are designed to fullfill both (I) and (II) in the chapter's introduction.\\

Breaking down BF further can be done conveniently using sub-simplicial sets, just like we used in the proof of prism filling. 

\begin{center}
\includegraphics[width=300pt]{boxfilling.png}
\end{center}


{\bf Decomposing (Î”Â¹)â¿ into a colimit involving n! Î”â¿'s} Consider the face maps fáµ¢ : Î”â¿ â­¢ Î”${}^{n+1}$


The decomposition 
The box filling lemma allows us to prove HEP:


The HEP in the last 

..H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary. Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

Imagine 




\chapter{Chapter 11: The Category of Maps of âˆ-Groupoids}








\part{BASED âˆ-CATEGORIES}

In this first section we prove the standard Whitehead theorem.\\


\chapter{Chapter 1: âˆ\texttt{-Catâ‚‹â‚}}


\noindent\textcolor{Red}{\rule{16cm}{1mm}}
\begin{center}
\texttt{Implementation Progress}
\end{center}
\noindent\textcolor{Red}{\rule{16cm}{1mm}}


%LEAN: CWComplex
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

/-- A relative CW-complex contains an expanding sequence of subspaces `sk i`
(called the `i`-skeleta) for `i â‰¥ -1`, where `sk (-1)` is an arbitrary topological space,
isomorphic to `A`, and each `sk (n+1)` is obtained from `sk n` by attaching (n+1)-disks. -/
structure RelativeCWComplex (A : TopCat) where
  /-- Skeleta -/
  sk : â„¤ â†’ TopCat
  /-- A is isomorphic to the (-1)-skeleton. -/
  iso_sk_neg_one : A â‰… sk (-1)
  /-- The (n+1)-skeleton is obtained from the n-skeleton by attaching (n+1)-disks. -/
  attach_cells : (n : â„¤) â†’ CWComplex.AttachCells (sk n) (sk (n + 1)) n

/-- A CW-complex is a relative CW-complex whose (-1)-skeleton is empty. -/
abbrev CWComplex := RelativeCWComplex (TopCat.of Empty)

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: CWComplexCat (topology)
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

/-- The topology on a relative CW-complex -/
def toTopCat {A : TopCat} (X : RelativeCWComplex A) : TopCat :=
  Limits.colimit (colimitDiagram X)

instance : Coe CWComplex TopCat where coe X := toTopCat X

\end{minted}
\end{tcolorbox}
\end{center}


%LEAN: CWComplexCat (category of CW complexes)
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||||]{lean}

def IsCWComplex (X : TopCat) : Prop := âˆƒ Y : CWComplex, Nonempty (â†‘Y â‰… X)

def CWComplexCat := FullSubcategory IsCWComplex

\end{minted}
\end{tcolorbox}
\end{center}



\noindent\textcolor{Red}{\rule{16cm}{1mm}}
\begin{center}
\texttt{Writing Progress}
\end{center}
\noindent\textcolor{Red}{\rule{16cm}{1mm}}



Here we define CW-complexes, as well as relative CW-complexes, and also the derived categories D(âˆ-Grpdâ‚€) of connected based âˆ-groupoids and D(âˆ-Grpdâ‚€/Gâ‚€), made from CW-complexes.\\

\section{D(âˆ-Grpdâ‚€)}

{\footnotesize
\begin{center}
\begin{tabular}{|| l || l || l || l ||} 
\hline
$\texttt{Symbol}$ & $\texttt{Unicode}$ & \texttt{VSCode shortcut} & $\texttt{Use}$\\
\hline
\multicolumn{4}{||c||}{\texttt{Lean's Kernel}} \\
\hline
Ã— & 2A2F & \backslash\texttt{times} & Product of types\\
\hline
â†’ & 2192 & \backslash\texttt{rightarrow}  & Hom of types\\
\hline
âŠ£ & 22A3 & \backslash\texttt{dashv}  & The condition that two functors are adjoint \\
\hline
?,Â¿ & 003F, 00BF & ?,\backslash\texttt{?}  & The corresponding (co)monad of an adjunction\\
\hline
âˆ¼ & 223C & \backslash\texttt{sim} & Homotopies \\
\hline
\end{tabular}
\end{center}}

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

\end{minted}
\end{tcolorbox}
\end{center}

\section{D(âˆ-Grpdâ‚€/Xâ‚€)}

The derived category of BASED âˆ-groupoids over Xâ‚€. \\

\section{Î© : âˆ-Grpdâ‚€ â­¢ âˆ-Grpd}



\section{Î£ : âˆ-Grpdâ‚€ â­¢ âˆ-Grpdâ‚€} 

The based suspension functor

\section{Ï‰ f : âˆ-Grpd/Dâ‚€ â­¢ âˆ-Grpd/Câ‚€}

The homotopy fiber

\section{Ïƒ f : âˆ-Grpdâ‚€/Câ‚€ â­¢ âˆ-Grpdâ‚€/Dâ‚€}

Based homotopy pushout

\section{Ï€â‚™ : âˆ-Grpdâ‚€ â­¢ Set}

The connected components functors

\iffalse
https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Homotopy/Basic.html
\fi



\chapter{Chapter 2: The Whitehead Theorem}

The proof of the Whitehead theorem divides into REP (replacement for BASED âˆ-groupoids X : âˆ-Grpdâ‚€) and HEP (the homotopy extension property for weak equivalent maps of based âˆ-groupoids). The replacement functor âˆ$\texttt{-Grpd}$â‚€ can be constructed using globular sets.\\

Globular sets are not a rich enough invariant for homotopy, but maps of globular sets bear a criticall difference because of 

\begin{center}
\texttt{âˆ€(E:D(âˆ-Grpdâ‚€)),âˆ€(B:D(âˆ-Grpdâ‚€)),âˆ€(f:E â­¢ B),âˆ€(G:E â­¢ B),(âˆ€(n:Nat),(Ï€â‚™ F = Ï€â‚™ G)) â­¢ F = G}
\end{center}

\section{Globular Sets}

The globe category ğ”¾ is the category

\begin{center}
\includegraphics[scale=0.5]{globecat.png}
\end{center}

\href{https://ncatlab.org/nlab/show/globular+set}{Globular sets} are functors from the opposite category of the globe category ğ”¾ into the category of sets, and maps of globular sets are natural transformations between them.\\

In this chapter we prove the following (which we have called Whitehead Theorem (c)): âˆ€(E:D(âˆ-Grpdâ‚€)),âˆ€(B:D(âˆ-Grpdâ‚€)),âˆ€(f:E â­¢ B),âˆ€(G:E â­¢ B),(âˆ€(n:Nat),(Ï€â‚™ F = Ï€â‚™ G)) â­¢ F = G, where Ï€â‚™ is notation for Ï€ n.\\

This can be shown using CW-replacement and induction on n. Fibrant replacement of an object X entails replacing an object in âˆ-Grpdâ‚€ with a CW-object (an object made by successively glueing in higher and higher simplices along their boundaries obtaining a sequence Xâ‚™). Given an equality Ï€${}_{n+1}(f) = $Ï€${}_{n+1}(g)$ and a homotopy equivalence hâ‚™ : Î”Â¹ Ã— Xâ‚™ â­¢ Y between $f|_{X_n}, g|_{X_n}$ : Xâ‚™ â­¢ Y, we construct an extension of the homotopy equivalence Î”Â¹ Ã— $X_{n+1}$ â­¢ Y.\\

\iffalse
Can the attaching map be 
\fi

{\bf Spheres and balls} Next we turn to defining spheres and balls:

{
\footnotesize
\begin{center}
\begin{tabular}{||l || l || l ||} 
 \hline
  & \multicolumn{2}{||c||}{\texttt{Spheres and Balls}} \\
 \hline
 Name of the $\texttt{X}$ value & \texttt{âˆ‚X â‰… Sâ¿} & \texttt{X â‰… Dâ¿} \\
 \hline
 \hline
 p-norm unit ball for p = 1 & âˆ‚B(1,1) & B(1,1) \\
 \hline
 p-norm unit ball for 1 < p < 2 & âˆ‚B(p,1) & B(p,1) \\
 \hline
 p-norm unit ball for p = 2 & âˆ‚B(2,1) & B(2,1) \\
 \hline
 p-norm unit ball for 2 < p < âˆ & âˆ‚B(p,1) & B(p,1) \\
 \hline
 p-norm unit ball for p = âˆ & âˆ‚B(âˆ,1) & B(âˆ,1) \\
 \hline
 The n-simplex & âˆ‚Î”â¿ & Î”â¿ \\
 \hline
 \hline
\end{tabular}
\end{center}
}

\begin{definition}
...
\end{definition}

\iffalse
\begin{definition}
Define a function d${}^{(n_1,...,n_k)} : $ D${}^{n_1}$ Ã— $\cdots$ Ã— D${}^{n_k}$ â­¢ D${}^{n_1 + \cdots + n_k}$ sending $(x_1,...,x_k)$...
\end{definition}
\fi

\begin{theorem}
iÂ¹ : Sâ° â­¢ DÂ¹ 
\end{theorem}

\begin{theorem}
Dâ¿ Ã— DÂ¹ â­¢ Dâ¿âºÂ¹
\end{theorem}

\begin{definition}
Dâ¿ â­¢ Dáµ
\end{definition}


\begin{theorem}
Fix n : â„• and let âˆ‚â¿ : Sâ¿ â­¢ Dâ¿âºÂ¹ be the inclusion. The pushout of the following diagram is isomorphic to Sâ¿âºÂ¹:
\begin{center}
\includegraphics[scale=0.5]{pushout.png}
\end{center}
\end{theorem}

\begin{proof}

\end{proof}


\begin{theorem}
Define a function ||-||${}_{2}$ : Dâ¿ â­¢ I sending (xâ‚,...,xâ‚™) to $\sqrt{\sum_{i = 1}^n x_i^2}$, and write ||-||${}_{2}$
\end{theorem}

\begin{proof}
...
\end{proof}

\section{HEP for BASED âˆ-groupoids}

In this section we prove the homotopy extension property for BASED âˆ-groupoids, which we here model as CW-complexes.\\


{\bf Jar filling} Next we turn to defining `jar shapes' $\texttt{Jâ¿}$, which include into $\texttt{Dâ¿ Ã— I}$ $\texttt{iâ‚™ : Jâ¿ â­¢ Dâ¿ Ã— I}$, after which we `fill' them (i.e. demonstrate that any continuous map f : Jâ¿ â­¢ X extends to a continuous map g : Dâ¿ Ã— I â­¢ X).\\

The first and most common approach involves `shining a light ray down from above the jar', i.e. projection. We obtain a formula for .\\

The second way to fill the jar




{\bf Change of Base} Jar filling leaves the question

\begin{definition}
Let Xâ‚‹â‚ be a connected CW-complex and let n : Nat be a natural number. The transport function $\texttt{trans\ n\ Xâ‚‹â‚ : (f : [I,Xâ‚‹â‚])  â†’ Ï€â‚™ (f 0) â­¢ Ï€â‚™ (f 1)}$ is 
\end{definition}

\begin{theorem}
Let Xâ‚‹â‚ be a connected CW-complex and let f : I â­¢ Xâ‚‹â‚ be a path, so that $\texttt{(trans\ n Xâ‚‹â‚ fâ»Â¹) â€¢ (trans\ n Xâ‚‹â‚ f)}$ has type $\texttt{Ï€â‚™ (f 0) â­¢ Ï€â‚™ (f 0)}$. Then
\begin{center}
$\texttt{(trans\ n Xâ‚‹â‚ fâ»Â¹) â€¢ (trans\ n Xâ‚‹â‚ f) = 1\_(Ï€â‚™ (f 0))}$
\end{center}
\end{theorem}

\begin{proof}
...
\end{proof}

The proof in the above can be depicted like so, as a `painting with two concentric frames':

\begin{center}
\includegraphics[scale=0.5]{windowframe.png}
\end{center}

that the based CW-complexes (Xâ‚‹â‚,x) and (Xâ‚‹â‚,y) are 

\begin{theorem}

\end{theorem}

\begin{proof}
...
\end{proof}

\begin{center}
\includegraphics[width=3.5cm,height=5cm]{proj.png}
\end{center}

 



\section{REP for based ??? âˆ-categories}

In this section we use the notion of globular sets to replace a topological space with a CW-complex. Together with HEP (homotopy extension), this will complete the proof of the Whitehead theorem.




\section{The Whitehead theorem}

Here we show the Whitehead theorem.

\iffalse
https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Homotopy/HomotopyGroup.html
\fi

\iffalse
In proving the Whitehead theorem formally, \textit{we make use of a line} as well as, in essence, the structure of a \textit{groupoid} $\texttt{G}_{\texttt{X}}$ where $\texttt{Hom}{}_{\texttt{G}}\texttt{(x,x)}$ is taken to be Ï€â‚™(X,x). This interesting feature of the proof relates to the other two Whitehead theorems featuring categories Î âƒ—â‚™ and groupoids Î â‚™.\\
\fi


\chapter{Chapter 3: The Category of Maps}

In this section I would like to 






\part{âˆ-CATEGORIES}

\chapter{Chapter 13: âˆ\texttt{-Cat}}

This chapter and the next chapter are more technical and difficult than the rest of the book.\\

\begin{enumerate}
\item Defining D(âˆ-Cat) by formally inverting weak equivalences.
\item Defining D(âˆ-Cat/C) by formally inverting weak equivalences.
\item Defining a fibrant replacement functor for âˆ-Cat
\item Defining a fibrant replacement functor for âˆ-Cat/C
\item We first construct both the category D(âˆ-Cat) and, for each C : D(âˆ-Cat), the category D(âˆ-Cat/C) by formally inverting weak equivalences in the category of quasicategories and the category of quasicategories over C.
\end{enumerate}

\section{Î©âƒ—}

Our choice of symbols refects our choice of three variations of the Whitehead theorem and three Puppe sequences. Î©âƒ—, the analogue of loop space, is the internal hom functor [Î”Â¹,-] : âˆ-Cat â­¢ âˆ-Cat. This is not hard to construct, with the main lemma being that the path space of a quasicategory has the quasicategory lifting conditon.\\

We will be interested in one formal model of D(âˆ-Cat) which consists of formal compositions fâ‚ â€¢ gâ‚ â€¢ fâ‚‚ â€¢ gâ‚‚ â€¢ â‹¯ â€¢ fâ‚™ â€¢ gâ‚™, where gâ‚™ $: Dom(f{}_{n+1}) $â­¢ ??? is a weak equivalence, and something similar for D(âˆ-Cat). However, it is still vital to have the replacement functor $\texttt{repl}$, which ensures the Whitehead theorem for particular âˆ-categories which are constructed out of attaching maps.\\


\section{Ï‰âƒ—}

Î©âƒ— is to internal categories as Ï‰âƒ— is to internal C-presheaves. It is also called directed homotopy pullback. These functors will later be used to produce functors Pâƒ— : D(âˆ-Cat) â­¢ InternalCategory D(âˆ-Cat) and pâƒ— : D(âˆ-Catâ„C) â­¢ InternalPresheaf (Pâƒ— C) D(âˆ-Catâ„C).\\


\section{Î âƒ—â‚™}

The mentioned functors Î âƒ—â‚™ are designed with both Whitehead theorem (a) and Puppe sequence (a) in mind.



\chapter{Chapter 14: The Whitehead Theorem for âˆ-Categories}

\iffalse
https://mathoverflow.net/questions/368596/intuition-for-categorical-fibrations#:~:text=a%20left%2Fright%20fibration%20is,categories%20with%20correspondences%20between%20fibers.
\fi


\section{Directed Cubical Complexes}

...\\


In this chapter, we take on the objective of Whitehead theorem (a), out of which we will prove the other more concrete Whitehead theorems:\\

\begin{center} âˆ€(E:D(âˆ-Cat)),âˆ€(B:D(âˆ-Cat)),âˆ€(F:E â­¢ B),âˆ€(G:E â­¢ B),(âˆ€(n:Nat),(Î âƒ—â‚™ F = Î âƒ—â‚™ G)) â­¢ F = G
\end{center}

We can attempt to form a slightly different category, much like the above, called ğ““(âˆ-Cat), at first, and in a formal way, so as to create a category whose object component ğ““(âˆ-Cat).Î± matches the object component âˆ-Cat.Î± while featuring the above theorem in a formal way. However, with this as our model of D(âˆ-Cat), we may then also be interested in the establishment of a model in which the Whitehead theorem is demonstrated, with the main idea being to prove two complementary concepts:

\begin{enumerate}
\item (REP) Establish a kind of ``weak equivalent fibrant replacement" R : âˆ-Cat.Î± â­¢ âˆ-Cat.Î± (.Î± gives the object component in Mathlib's category theory library), analogous to CW-complex replacement in Whitehead's original paper. It's especially nice if R forms the object component of a functor F : âˆ-Cat â­¢ âˆ-Cat. D(F) : D(âˆ-Cat) â­¢ D(âˆ-Cat) should be a categorical equivalence, and that is what we will do.
\item (HEP) For the object R X, demonstrate that any F,G : (R X) â­¢ Y such that âˆ€(n:Nat),(Î âƒ—â‚™ F = Î âƒ—â‚™ G), there is a directed homotopy equivalence between F and G. Note that ``directed homotopy equivalence" consists of a composible sequence of simple directed homotopies Háµ¢ : Î”Â¹ Ã— (R X) â­¢ Y, 1 â‰¤ i â‰¤ n, with even Háµ¢ running reverse to the odd Háµ¢.
\end{enumerate} 

Both of these will use induction on Lean's $\texttt{Nat}$. The first of these could be called a REP (for REplacement Property, but this isn't usual terminology), and the second typically uses induction and a HEP (Homotopy Extension Property). Our REPa will consist of objects made out of particular kinds of pushouts called attaching maps, and can be made functorial. Proving the HEPa can be done by well-order induction on the attaching maps present in our choice of R, thereby reducing to the case of extending a homotopy along a single attachment.\\

Our HEPa (directed box filling) is similar to the HEP shown in Whitehead's original paper, and to the approach detailed in Hatcher's textbook, though no doubt modified to suit our two goals:

\begin{enumerate}[(I)]
\item The analogue of the Puppe sequence on the front cover needs to hold.
\item The first Whitehead theorem on the front cover needs to hold.
\end{enumerate}

These two considerations determine our choice of Î âƒ—â‚™, Î©âƒ—, and Ï‰âƒ—. We take Î©âƒ— to be (simply) the internal hom functor [Î”Â¹,-] (which requires showing that Î©âƒ—X has the inner-horn filling condition). Ï‰âƒ— is then defined as a certain pullback of Î©âƒ—, and Î âƒ—â‚™ is designed to produce a Puppe sequence with a meaningful notion of exactness by which we can demonstrate the goal of recognition theorems (i) and (ii). Specifically, it makes sense to use cubes in our definition of Î âƒ—â‚™ because of how they are representing objects of Î©âƒ—â¿. Meanwhile, it is also clear that the quotient producing Î âƒ—â‚™ is subtle in exactly how it requires fixing the endpoints of a sequence of alternating directed homotopies. We will define Î âƒ—â‚™'s by identifying those objects x, y: Î©âƒ—â¿ X which are homotopic by a homotopy which restricts to a constant along the face maps fáµ¢ : Î©âƒ—${}^{n-1}$ X â­¢ Î©âƒ—${}^{n-1}$ X (which correspond to Maps (n,b), where b : Bool).\\

Imagine for a moment the picture of a square shaped cusion; we might make such a cusion by first soeing together 6 squares of cloth and filling it with material, then "soeing the walls down to a square". Here we go with this:

\begin{enumerate}
\item Define a n-cubical cusion using the boundary of an n-1 cube times Î”Â¹, i.e. the quotient of (Î”Â¹)${}^{n-1}$ Ã— Î”Â¹ by an equivalence relation, but we have to start our model somewhere), or perhaps more easily the pushout of f : Î”Â¹ Ã— (âˆ‚((Î”Â¹)â¿)) â­¢ (Î”Â¹)${}^{n+1}$ by the projection map Î”Â¹ Ã— (âˆ‚((Î”Â¹)â¿)) â­¢ âˆ‚((Î”Â¹)â¿)
\item Define a simplicial cusion using the boundary of an n-1 simplex times Î”Â¹, i.e. the quotient of (Î”Â¹) by an equivalence relation, or perhaps more easily the pushout of f : Î”Â¹ Ã— (âˆ‚(Î”â¿)) â­¢ (Î”Â¹) Ã— Î”â¿ by the projection map Î”Â¹ Ã— (âˆ‚((Î”Â¹)â¿)) â­¢ âˆ‚(Î”â¿)
\end{enumerate}

The boundary of a cusion is a pouch, isomorphic to a pushout of two cubes glued together at their boundaries:

\begin{enumerate}
\item Define a n-cubical pouch as the pushout of two boundary maps âˆ‚((Î”Â¹)â¿) â­¢ (Î”Â¹)â¿
\item Define a simplicial pouch as the pushout of two boundary maps âˆ‚(Î”â¿) â­¢ Î”â¿
\end{enumerate}

Notice that paths in Î©âƒ—â¿X produce paths in Î©âƒ—${}^{n-1}$X in as many ways as there are face maps (Î”Â¹)${}^{n-1}$ â­¢ Î”Â¹${}^{n}$, these could be called restrictions and are no doubt related to the pouches and cusions we just defined. The cartesian closed structure on simplicial sets with the lifting condition clarifies the relationship between the two available definitions of Î âƒ—â‚™:

\begin{enumerate}
\item Homotopies of maps from a cube which are constant on the boundary
\item Paths of maps in Î©âƒ—${}^{n-1}$X which produce constant maps under the mentioned restritions.
\item Maps from a pouch mod an equivalence relation (really we phrase this as a pushout!), namely the equivalence relation in which any two maps from a pouch that extend to maps from a cusion are identified.
\end{enumerate}

After we construct Î âƒ—â‚™ in the first section, we will be in a place to demonstrate that the natural transformation $\texttt{weak\_equivalence : repl â­¢ (ğŸ™ }$âˆ$\texttt{-Cat)}$ consists of weak equivalences (a fact which we call REP, which is short for REplacement Principal). This is covered in the section titled REP, which also constructs $\texttt{repl}$ and $\texttt{weak\_requivalence}$.\\

In sum, the goal of the present chapter is to use similar insights to the proof of the Whitehead theorem featured Hatcher's textbook to prove Wa and Pa for the model of quasicategories, using Mathlib's predefined horns and simplices in its simplicial sets section. The main difference is that our work must take care to respect the directed nature of quasicategories.\\

\iffalse
In the future, we intend to add important aspects of the bigger picture besides those which directly establish REP and HEP in the sections below. These are important considerations in ensuring usability. Three different model structures on âˆ-Cat ensue from the six definitions below, which are contained in Lurie's ``Higher Topos Theory" on page 53, and which are due to Joyal:

\begin{definition} A morphism $\texttt{f : X â­¢ S}$ of simplicial sets is
\begin{enumerate}
\item A left fibration if f has the right lifting property with respect to all
horn inclusions Î›ni âŠ† âˆ†n, 0 â‰¤ i < n.
\item A right fibration if f has the right lifting property with respect to all
horn inclusions Î›ni âŠ† âˆ†n, 0 < i â‰¤ n.
\item An inner fibration if f has the right lifting property with respect to all
horn inclusions Î›ni âŠ† âˆ†n, 0 < i < n.
\end{enumerate}
A morphism of simplicial sets $\texttt{i : A â­¢ B}$ is
\begin{enumerate}
\item left anodyne if $\texttt{i}$ has the left lifting property with respect to all left fibrations.
\item right anodyne if $\texttt{i}$ has the left lifting property with respect to all right fibrations.
\item inner anodyne if $\texttt{i}$ has the left lifting property with respect to all inner fibrations.
\end{enumerate}
\end{definition}
\fi

\begin{enumerate}
\item Defining $\texttt{repl}$
\item 
\end{enumerate}

\section{REP}

We have divided the work of proving Whitehead theorem (a) into two steps: REP and HEP. In this section, we construct a functor $\texttt{repl : }$âˆ$\texttt{-Cat â­¢ }$âˆ$\texttt{-Cat}$ along with a natural transformation $\texttt{weak\_equivalence : repl â­¢ (ğŸ™ }$âˆ$\texttt{-Cat)}$. To construct $\texttt{repl}$ 


\section{HEP}

Consider the context of , supposing that we have constructed a homotopy ... This gives a picture that is a bit like ``filling up a jar``: a homotopy h : of f, g : âˆ‚Î”Â² â­¢ Y, along with the value of g on Î”Â², produces a ``jar" shape in Y, which can be ``filled up" to produce a homotopy h : Î”Â¹ Ã— Î”Â² â­¢ Y. This is easier for simplicial-based approaches than for point-set topological approaches, the latter of which needs extra steps that deform a map into a cellular map.\\

This construction, in the case of point set topology, often involves first deforming maps so as to be cellular; however our analogue of CW complexes allows us to skip this step.\\

This construction (HEP for quasicategories) may even be equivalent to the quasicategory lifting condition if we are lucky. It is also the main technical device allowing for our concrete choice of model (quasicategories).\\

In this section, we demonstrate this extension property and use it to conclude the Whitehead theorem for âˆ-categories stated above.\\

\begin{center}
\includegraphics[width=0.5\textwidth]{HEP.png}
\end{center}

{\bf Prism Filling (PF)} Let Y be a quasicategory, and let f, g : âˆ‚Î”â¿ â­¢ Y. A homotopy h : âˆ‚Î”â¿ Ã— Î”Â¹ â­¢ Y between f, g : âˆ‚Î”â¿ â­¢ Y extends to a map H : Î”â¿ Ã— Î”Â¹ â­¢ Y; this follows from the condition that Y be a quasicategory. H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary. Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

Directed prism filling may combine fruitfully with the yoneda lemma and/or the fact that simplicial sets are determined by the sets [Î”â¿,X] along with combinatorial information (face and degeneracy maps).

{\bf Decomposing Î”â¿ Ã— Î”Â¹ into a colimit involving n+1 Î”${}^{n+1}$'s} ...

\begin{center}
\includegraphics[width=300pt]{prismfilling.png}
\end{center}

In the above, it may be easier if we make use of sub-simplicial sets and prove the theorem using that colimit applied to a natural isomorphism of diagrams products an isomorphism.\\

The decomposition 

A definition of Î âƒ—â‚™ which is consistent with our goals of Wa and Pa is one as a certain pushout involving (Î©âƒ—â¿ X)-- one which amounts to taking an equivalence relation by paths in Î©âƒ—â¿ X which restrict to constant paths along the face maps fáµ¢ : Î©âƒ—${}^{n-1}$ X â­¢ Î©âƒ—â¿ X. Here, Î©âƒ— is easy to define in the model of quasi-categories, and it amounts . Besides fullfilling our goal of the first Whitehead theorem and puppe sequence, this definition of Î âƒ—â‚™ strikes me as elegant because it uses all of the ways for Î©âƒ—â¿ X to map into Î©âƒ—${}^{n+1}$ X.\\

The next symbols in the project's ``periodic table" that we construct, after Î©âƒ— and Î âƒ—â‚™, will be Bâƒ— and Eâƒ—, which we feature in the chapter on Puppe sequence (a).\\

A useful thing for us to construct first is the boundary of a product of Î”Â¹'s and the boundary of a directed simplex. We might even like to expand on this later, but for now just consider for a moment how each might be made out of a glueing construction involving face maps.\\

Even though the Î âƒ—â‚™'s can be defined using Î©âƒ—â¿ X and various face maps f$\_(n,b)$ : Î©âƒ—${}^{n-1}$ X â­¢ Î©âƒ—${}^{n}$ X for $b : \{ 0, 1 \}$, it may be nice to have this as a result, with the definition one featuring two cubes glued together along their boundary.\\

This means that we want directed box filling in addition to directed prism filling (but which also uses directed prism filling in its proof).

{\bf Box Filling (BF)} Let Y be a quasicategory, and let f, g : âˆ‚Î”â¿ â­¢ Y. A homotopy h : âˆ‚Î”â¿ Ã— Î”Â¹ â­¢ Y between f, g : âˆ‚Î”â¿ â­¢ Y extends to a map H : Î”â¿ Ã— Î”Â¹ â­¢ Y; this follows from the condition that Y be a quasicategory. H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary. Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

This goes hand-in-hand with a definition of Î âƒ—â‚™ which suits (I) and (II) in the introduction to chapter (3). If we make sure to prove lemmas... 

The box filling and prism filling HEPs can be extended to the case of attaching all cells of a particular fixed dimension and as indexed by simplicial set arising from a set (or Lean 4 $\texttt{Type}$). That is, we might like to extend Ã— $()$ (or possibly somehow a $\texttt{Set}$ as well), and that we may find an interest in the following two definitions of Î âƒ—â‚™, which are designed to fullfill both (I) and (II) in the chapter's introduction.\\

Breaking down BF further can be done conveniently using sub-simplicial sets, just like we used in the proof of prism filling. 

\begin{center}
\includegraphics[width=300pt]{boxfilling.png}
\end{center}


{\bf Decomposing (Î”Â¹)â¿ into a colimit involving n! Î”â¿'s} Consider the face maps fáµ¢ : Î”â¿ â­¢ Î”${}^{n+1}$


The decomposition 
The box filling lemma allows us to prove HEP:


\section{The Whitehead Theorem for âˆ-Cat}

The HEP in the last 

..H(-,1) and g match on âˆ‚Î”â¿, producing a map f : X â­¢ Y, where X consists of two copies of Î”â¿ glued together at the boundary. Consider a space X' formed as a quotient of Î”â¿ Ã— Î”Â¹ by âˆ‚Î”â¿ Ã— Î”Â¹. There is a map Ï† : X â­¢ X'. An induction hypothesis on f and g involving Ï€â‚™ ensures that the aparent map X â­¢ Y lifts along Ï†, producing a map from Î”â¿ Ã— Î”Â¹ which is constant on âˆ‚Î”â¿ Ã— Î”Â¹. Stacking this on top of H can be done using an isomorphism between Î”Â¹ and Î”Â¹ glued with itself along different endpoints. Altogether this produces a homotopy between f and g.\\

Imagine 


\chapter{Chapter 15: The Category of Maps of âˆ-Categories}

...\\






\part{CATEGORIES AND E${}^k$-CATEGORIES}

In this section we establish the following notions:

internal operad, enriched operad, internal operoid, and enriched operoid. These structures pertain to categories in which one can 


{
\footnotesize
\begin{center}
\begin{tabular}{| l || l | l || l | l ||} 
 \hline
\texttt{Strict/Lax} & $\texttt{Category}$  &\ $\texttt{Operoid}$ \\
 \hline \hline
\texttt{Internal/Enriched} & $\texttt{Internal}$ & $\texttt{Enriched}$ & $\texttt{Internal}$ & $\texttt{Enriched}$ \\ 
 \hline \hline
$\texttt{C.Obj â‰… terminal\_object â„‚}$ & & & & \\ 
 \hline
$\texttt{C.Obj â‰… terminal\_object â„‚}$ & & & & \\ 
 \hline
  & & & & \\ 
 \hline
 & & & & \\ 
 \hline
& & & & \\ 
 \hline
\end{tabular}
\end{center}
}

\iffalse


\chapter{Chapter 4: Internal and Operadic Groups}

\iffalse
An operadic group is an algebra for the little lines operad, which has ??? entries

An operadic internal group in an âˆ-category C is an algebra for the little lines internal operad, which has ??? entries.
\fi

\section{\texttt{InternalGroup}}

%LEAN: internal_group
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

/-
structure internal_group ... where
  Obj := D(Î“).Obj
-- Dom := 
-- Cod
-- Idn
-- Fst
-- Snd
-- Cmp
-- Idâ‚
-- Idâ‚‚
-- Ass
-- Com
-/

\end{minted}
\end{tcolorbox}
\end{center}


\section{\texttt{InternalGroupAction G}}

Here we define internal group actions. These will be important when we talk about G-principal bundles (themselves defined as internal group actions in the derived category of an overcategory). 


\section{\texttt{OperadicGroup}}




\section{\texttt{OperadicGroupActions}}



\section{The \texttt{O} and \texttt{P} Functors}

The internal group principal stems from the simple observation that the loop space forms a component of an internal group.\\


\section{The \texttt{o} and \texttt{p} Functors}

The internal group actions principal stems from the simple observation that the homotopy fiber forms a component of an internal group action.\\


\fi





\iffalse
 \multicolumn{2}{||c||}{\texttt{Chapter 4: }Internal and Operadic Groups} \\
\hline \hline
 $\texttt{InternalGroup}$   & The category of internal groups in Î“  \\
 \hline
 $\texttt{InternalGroupAction Gâ‚€}$ & The category of internal Gâ‚€-actions in Î“   \\
 \hline
  $\texttt{OperadicGroup}$  & The category of operadic groups  \\
 \hline
 $\texttt{OperadicGroupAction}$  & The category of operadic group actions  \\
 \hline
  The $\texttt{P}$ and $\texttt{O}$ Functors & $\texttt{P = ? â€¢ O}$ \\
 \hline
 The $\texttt{p}$ and $\texttt{o}$ Functors & $\texttt{p = ? â€¢ o}$ \\
\hline \hline

\multicolumn{2}{||c||}{\texttt{Chapter 8: }Internal and Operadic Groupoids and their Actions} \\
\hline \hline
 $\texttt{InternalGroupoid Î“}$   & The category of internal groupoids in Î“ \\
 \hline
 $\texttt{InternalGroupoidAction Î“ G}$ & The category of internal G-actions in Î“ \\
 \hline
  $\texttt{OperadicGroupoid Î“}$  & The category of operadic groupoids  \\
 \hline
 $\texttt{OperadicGroupoidAction Î“}$  & The category of operadic groupoid actions  \\
  \hline
  The $\texttt{Pâƒ¡}$ and $\texttt{Oâƒ¡}$ Functors & $\texttt{Pâƒ¡ = ? â€¢ Oâƒ¡}$ \\
 \hline
 The $\texttt{pâƒ¡}$ and $\texttt{oâƒ¡}$ Functors & $\texttt{pâƒ¡ = ? â€¢ oâƒ¡}$ \\
 \hline \hline

\multicolumn{2}{||c||}{\texttt{Chapter 12: Internal and Operadic Categories and their Sheaves}} \\
\hline \hline
 $\texttt{InternalCategory : ???}$   & The category of internal categories \\
 \hline
 $\texttt{InternalPresheaf : ???}$  & The category of internal presheaves \\
 \hline
  $\texttt{OperadicCategory : Cat â†’ Cat}$  & The category of operadic categories  \\
 \hline
 $\texttt{OperadicPresheaf : Cat â†’ Cat}$   & The category of operadic presheaves  \\
  \hline
  The $\texttt{Pâƒ—}$ and $\texttt{Oâƒ—}$ Functors & $\texttt{Pâƒ— = ? â€¢ Oâƒ—}$ \\
 \hline
 The $\texttt{pâƒ—}$ and $\texttt{oâƒ—}$ Functors & $\texttt{pâƒ— = ? â€¢ oâƒ—}$ \\
 \hline \hline
\fi



\iffalse
\chapter{Chapter 12: Internal and Operadic Groupoids and their Actions}

In this chapter, we discuss internal categories and internal presheaves in a pullback system. We may keep in mind that internal categories and internal presheaves can be formed in any category with pullbacks, even though we focus on the case of pullback systems because of our interest in Whitehead theorem (a).\\

After defining the category of internal categories D(Î“), we proceed to observe how, for C , D : D(Î“), F : C â­¢ D, (Ï‰âƒ— F).obj F forms an internal categry. Further, in considering internal (Pâƒ—\_(Î“) F)-presheaves for  C , D : D(Î“), F : C â­¢ D, we proceed to make observations about (Ï‰âƒ— F).obj G.\\

{
\footnotesize
\begin{center}
\begin{tabular}{||l || l ||} 
 \hline
 $\texttt{Section}$  &\ $\texttt{Description}$ \\
 \hline \hline
 $\texttt{InternalGroupoid : Cat}$   &\ Internal categories \\ 
 \hline
 $\texttt{InternalGroupoidAction G : Cat}$ &\ Internal C-presheaves \\ 
 \hline
 The internal category principal &\ \texttt{f Ã—\_(B) f} forms an internal category\\
 \hline
 The internal presheaf principal &\ \texttt{f Ã—\_(B) f} forms an internal presheaf\\
 \hline
 Pâƒ— C : InternalCategory D(âˆ-Cat) &\ Î©âƒ— C forms a component of an internal category \\
 \hline
 pâƒ— (ğŸ™ C) D : InternalPresheaf D(âˆ-Catâ„C) (Pâƒ— C) &\ Ï‰âƒ— (ğŸ™ C) D forms a component of an internal C-presheaf \\
 \hline
\end{tabular}
\end{center}
}


\section{\texttt{Internal Groupoids}}

In this chapter I define an \href{https://ncatlab.org/nlab/show/internal+category}{internal category}. Internal categories are most commonly defined on categories with enough pullbacks, but here I may also like to keep in mind that it is valuable to be able to iterate $\texttt{InternalGroupoid}$ in the way of composition.\\

\begin{definition}[Internal groupoids] 
\begin{enumerate}
\item An object $\texttt{â„‚.Mor : â„‚}$ 
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Idn : C.Hom â„‚.Obj â„‚.Mor}$
\item A term $\texttt{X : (pullback â„‚.Cod â„‚.Dom)}$
\item A term $\texttt{Xâ‚ : (pullback â„‚.Cod X.Prâ‚)}$
\item A term $\texttt{Xâ‚‚ : (pullback X.Prâ‚‚ â„‚.Dom)}$
\item A morphism $\texttt{â„‚.Mul : C.Hom X.Obj â„‚.Mor}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Mul =  Proj Ã— â„‚.Mul â€¢ â„‚.Cod}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = Prâ‚ â€¢ â„‚.Mul}$
\item A term $\texttt{â„‚.Idâ‚ : â„‚.Mul â€¢ (â„‚.Idn Ã— ğŸ™\_(â„‚.Mor)) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Idâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Idn) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Ass : â„‚.Mul â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul)}$
\item A term $\texttt{â„‚.Inv : â„‚.Mul = â„‚.Mul}$
\item A term $\texttt{â„‚.Eqâ‚ : â„‚.Mul â€¢ (â„‚.Inv Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Idn â€¢ â„‚.Dom}$
\item A term $\texttt{â„‚.Eqâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul) = â„‚.Idn â€¢ â„‚.Cod}$
\end{enumerate}
\end{definition}


%LEAN: definition of an internal groupoid in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of an internal category in a pullback system
/-
structure internal_groupoid (Î“ : Cat) where
  Obj : .Obj
  Mor : .Obj
  Dom : .Hom Mor Obj
  Cod : .Hom Mor Obj
  Idn : .Hom Obj Mor
  Fst : .Cmp Obj Mor Obj Idn Dom  = ğŸ™_(Î“.Obj) Obj
  Snd : .Cmp Obj Mor Obj Idn Cod = ğŸ™_(Î“.Obj) Obj
--  Cmp : D(Î“).Î“.PulObj ...
-- Idâ‚ : D(Î“).
-- Idâ‚‚ : D(Î“).
-- Ass : D(Î“).
-/

\end{minted}
\end{tcolorbox}
\end{center}

The internal functor structure combines with the internal category structure to give a category of internal categories in a pullback system.\\

\begin{definition}[Internal functors between internal groupoids] 
\begin{enumerate}
\item An object $\texttt{â„‚.Mor : â„‚}$ 
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Idn : C.Hom â„‚.Obj â„‚.Mor}$
\item A term $\texttt{X : (pullback â„‚.Cod â„‚.Dom)}$
\item A term $\texttt{Xâ‚ : (pullback â„‚.Cod X.Prâ‚)}$
\item A term $\texttt{Xâ‚‚ : (pullback X.Prâ‚‚ â„‚.Dom)}$
\item A morphism $\texttt{â„‚.Mul : C.Hom X.Obj â„‚.Mor}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Mul =  Proj Ã— â„‚.Mul â€¢ â„‚.Cod}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = Prâ‚ â€¢ â„‚.Mul}$
\item A term $\texttt{â„‚.Idâ‚ : â„‚.Mul â€¢ (â„‚.Idn Ã— ğŸ™\_(â„‚.Mor)) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Idâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Idn) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Ass : â„‚.Mul â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul)}$
\item A term $\texttt{â„‚.Inv : â„‚.Mul = â„‚.Mul}$
\item A term $\texttt{â„‚.Eqâ‚ : â„‚.Mul â€¢ (â„‚.Inv Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Idn â€¢ â„‚.Dom}$
\item A term $\texttt{â„‚.Eqâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul) = â„‚.Idn â€¢ â„‚.Cod}$
\end{enumerate}
\end{definition}

%LEAN: definition of an internal functor in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of an internal functor in a pullback system
structure internal_functor (Î“ : pullback_system) (C : internal_category Î“) (D : internal_category Î“) where
  Obj : D(Î“).Hom C.Obj D.Obj
-- Mor : D(Î“).
-- Fst : D(Î“).
-- Snd : D(Î“).
-- Idn : D(Î“).
-- Cmp : D(Î“).
--
--


\end{minted}
\end{tcolorbox}
\end{center}


%LEAN: definition of the identity internal functor in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of the identity internal functor in a pullback system
def InternalCategoryIdn (Î“ : pullback_system) (C : internal_category Î“) : (internal_functor Î“ C C) := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: definition of the composition of internal functors in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of the composition of internal functors in a pullback system
def InternalCategoryCmp (Î“ : pullback_system) (C : internal_category Î“) (D : internal_category Î“) (E : internal_category Î“) (F : internal_functor Î“ C D) (G : internal_functor Î“ D E) : (internal_functor Î“ C E) := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the first identity law for internal categories in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the the first identity law for internal categories in a pullback system
def InternalCategoryIdâ‚ (Î“ : pullback_system) (X : internal_category Î“) (Y : internal_category Î“) (f : internal_functor Î“ X Y) : InternalCategoryCmp Î“ X Y Y f (InternalCategoryIdn Î“ Y) = f := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the second identity law for internal categories  in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the second identity law for internal categories in a pullback system
def InternalCategoryIdâ‚‚ (Î“ : pullback_system) (X : internal_category Î“) (Y : internal_category Î“) (f : internal_functor Î“ X Y) : (InternalCategoryCmp Î“ X X Y (InternalCategoryIdn Î“ X) f = f) := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the associativity law for internal categories in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the associativity law for internal categories in a pullback system
def InternalCategoryAss (Î“ : pullback_system) (W : internal_category Î“) (X : internal_category Î“) (Y : internal_category Î“) (Z  : internal_category Î“) (f : internal_functor Î“ W X) (g : internal_functor Î“ X Y) (h : internal_functor Î“ Y Z) : InternalCategoryCmp Î“ W X Z f (InternalCategoryCmp Î“ X Y Z g h) = InternalCategoryCmp Î“ W Y Z (InternalCategoryCmp Î“ W X Y f g) h := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: defining the category of internal categories in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

/-
def InternalCategory (Î“ : pulback_system) : ğ‚ğšğ­.Obj := {Obj := internal_category Î“, Hom := internal_functor Î“, Idn := InternalCategoryIdn Î“, Cmp := InternalCategoryCmp Î“, Idâ‚ := InternalCategoryIdâ‚ Î“, Idâ‚‚ := InternalCategoryIdâ‚‚ Î“, Ass := InternalCategoryAss Î“}
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- notation : 2000 "Cat_(" Î“ ")" => InternalCategory Î“

\end{minted}
\end{tcolorbox}
\end{center}

\section{\texttt{InternalGroupoidAction Î“ C}}

The mentioned book $\textit{Galois Theories}$ by Janelidze and Borceux features a definition of internal presheaves for an internal groupoid in chapter 7 which makes a good reference for the present discussion.\\

%LEAN: internal C-presheaves
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- internal C-presheaves
-- def internal_presheaf (C : (InternalCategory C).Obj) : Type := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: defining an internal functor between internal C-presheaves
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- defining an internal functor between internal C-presheaves
/-
def Shfhom (C : (InternalCategory Î“).Obj) (F : internal_presheaf Î“ C) (G : internal_presheaf Î“ C) : Type := sorry
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: defining the identity internal functor of an internal C-sheaf
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- defining the identity internal functor of an internal C-sheaf
/-
def Shfidn (Î“ : pullback_system) (C : (InternalCategory Î“).Obj) (F : internal_presheaf Î“ C) : ShfHom Î“ C F F := sorry
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: defining the composition of internal functors
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- defining the composition of internal functors
def Shfcmp (Î“ : pullback_system) (C : (InternalCategory Î“).Obj) (F : internal_presheaf Î“ C) (G : internal_presheaf Î“ C) (H : internal_presheaf Î“ C) (f : ShfHom Î“ C F G)  (g : ShfHom Î“ C G H) : ShfHom Î“ C F H := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the first identity law for internal functors
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the first identity law for internal functors
/-
def Shf... (Î“ : pullback_system) (C : (InternalCategory Î“).Obj) (X : internal_presheaf Î“ C) (Y : internal_presheaf Î“ C) (f : ShfHom Î“ C X Y) : ((ShfCmp Î“ C X Y Y f (ShfIdn Î“ C Y)) = f) := sorry
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the second identity law for internal functors
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the second identity law for internal functors
/-
def ShfIdâ‚‚ (Î“ : pullback_system) (C : (InternalCategory Î“).Obj) (X : internal_presheaf Î“ C) (Y : internal_presheaf Î“ C) (f : ShfHom Î“ C X Y) : ((ShfCmp Î“ C X X Y (ShfIdn Î“ C X) f) = f) := sorry
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the associativity law for internal functors
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the associativity law for internal functors
/-
def ShfAss (Î“ : pullback_system) (C : (InternalCategory Î“).Obj) (W : internal_presheaf Î“ C) (X : internal_presheaf Î“ C) (Y : internal_presheaf Î“ C) (Z : internal_presheaf Î“ C) (f : ShfHom Î“ C W X) (g : ShfHom Î“ C X Y) (h : ShfHom Î“ C Y Z) : (ShfCmp Î“ C) W X Z f ((ShfCmp Î“ C) X Y Z g h) = (ShfCmp Î“ C) W Y Z ((ShfCmp Î“ C) W X Y f g) h := sorry
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

/-
def InternalPresheaf (Î“ : pullback_system) (C : (InternalCategory Î“).Obj) : ğ‚ğšğ­.Obj := {Obj := internal_presheaf Î“ C, Hom := ShfHom Î“ C, Idn := ShfIdn Î“ C, Cmp := ShfCmp Î“ C, Idâ‚ := ShfIdâ‚ Î“ C, Idâ‚‚ := ShfIdâ‚‚ Î“ C, Ass := ShfAss Î“ C}
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

/-
notation : 2000 "Shf_(" Î“ ")" => InternalPresheaf Î“
-/

\end{minted}
\end{tcolorbox}
\end{center}

Next we approach the internal category principal and internal presheaf principals, which concern how (directed) homotopy pullback can produce internal categories and internal presheaves.\\



\section{Operadic Groupoids}




\section{Operadic Groupoid Actions}



\section{The Pâƒ¡ and Oâƒ¡ Functors}

In this section we mention the internal category principal...\\


\section{The pâƒ¡ and oâƒ¡ Functors}

Next we mention the internal presheaf principal, which says that the pullback of any morphism with another forms a component of an internal presheaf in any category with pullbacks. Just as is the case for the last theorem, the most general form of this idea works for non-commutative analogues of pullback, wheras the case of pullback gives an internal groupoid action.\\


\fi


\iffalse

\chapter{Chapter 16: Internal and Operadic Categories and their Presheaves}

\iffalse
An operadic category is an algebra for the little rays operoid with 7 entries

An operadic internal category in C is an algebra in C for the little rays internal operoid with 13 entries

\fi

In this chapter, we discuss internal categories and internal presheaves in a pullback system. We may keep in mind that internal categories and internal presheaves can be formed in any category with pullbacks, even though we focus on the case of pullback systems because of our interest in Whitehead theorem (a).\\

After defining the category of internal categories D(Î“), we proceed to observe how, for C , D : D(Î“), F : C â­¢ D, (Ï‰âƒ— F).obj F forms an internal categry. Further, in considering internal (Pâƒ—\_(Î“) F)-presheaves for  C , D : D(Î“), F : C â­¢ D, we proceed to make observations about (Ï‰âƒ— F).obj G.\\

{
\footnotesize
\begin{center}
\begin{tabular}{||l || l ||} 
 \hline
 $\texttt{Section}$  &\ $\texttt{Description}$ \\
 \hline \hline
 $\texttt{InternalCategory Î“ : Cat}$   &\ Internal categories \\ 
 \hline
 $\texttt{InternalPresheaf Î“ C : Cat}$ &\ Internal C-presheaves \\ 
 \hline
 The internal category principal &\ \texttt{f Ã—\_(B) f} forms an internal category\\
 \hline
 The internal presheaf principal &\ \texttt{f Ã—\_(B) g} forms an internal presheaf\\
 \hline
 Pâƒ— C : InternalCategory D(âˆ-Cat) &\ Î©âƒ— C forms a component of an internal category \\
 \hline
 pâƒ— (ğŸ™ C) D : InternalPresheaf D(âˆ-Catâ„C) (Pâƒ— C) &\ Ï‰âƒ— (ğŸ™ C) D forms a component of an internal C-presheaf \\
 \hline
\end{tabular}
\end{center}
}

\iffalse
Definition of an operad ()
Definition of an 
Algebras for the little rays operoid
Algebras for the little lines operoid
Algebras for the little rays operad
Algebras for the little lines operad
\fi

\section{\texttt{Internal Categories}}

In this section I define an \href{https://ncatlab.org/nlab/show/internal+category}{internal category}, which structure plays a central role in \href{https://github.com/linlib/TheWhiteheadTheoremandTwoVariations/blob/main/Galois%20Theories%20Chapter%207%20(Janelidze%20and%20Borceux).pdf}{$\textit{Galois Theories}$} by Janelidze and Borceux.\\

Recall that, for a category C, with objects X${}_1$, X${}_2$, Y : C and morphisms $f_1$ : C.Hom X${}_1$ Y and $f_2$ : C.Hom X${}_2$ Y a pullback consists of:

\begin{definition}[Pullback] 
\begin{enumerate}
\item An object $\texttt{(pullback f_1 f_2).Obj : C}$
\item A morphism $\texttt{Pr}_1$ $\texttt{C.Hom (pullback f_1 f_2).Obj X}$${}_1$ 
\item A morphism $\texttt{Pr}_2$ $\texttt{C.Hom (pullback f_1 f_2).Obj X}$${}_2$ 
\item An equality $\texttt{Eqn :} \texttt{Pr}_1 \texttt{f}_1 = \texttt{Pr}_2 \texttt{f}_2$
\item A term $\texttt{p : âˆ€(X : C),g}_1 : C.Hom X X_1$, $\texttt{g}_1 : C.Hom X X_2, \texttt{f}_1 â€¢ \texttt{g}_1 = \texttt{f}_2 â€¢ \texttt{g}_2$, $\texttt{(âˆƒ!(h : C.Hom X (pullback f g).Obj),Pr_1 â€¢ h = g_1,Pr_2 â€¢ h = g_2)}$
\end{enumerate}
\end{enumerate}

In $\texttt{Categories and Hilbert Spaces}$, this was implemented as :

Let C be a category. An internal category â„‚ consists of:

\begin{definition}[Internal Category] 
\begin{enumerate}
\item An object $\texttt{â„‚.Obj : â„‚}$
\item An object $\texttt{â„‚.Mor : â„‚}$ 
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Dom : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Idn : C.Hom â„‚.Obj â„‚.Mor}$
\item A term $\texttt{X : (pullback â„‚.Cod â„‚.Dom)}$
\item A term $\texttt{Xâ‚ : (pullback â„‚.Cod X.Prâ‚)}$
\item A term $\texttt{Xâ‚‚ : (pullback X.Prâ‚‚ â„‚.Dom)}$
\item A morphism $\texttt{â„‚.Mul : C.Hom X.Obj â„‚.Mor}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Mul =  Proj Ã— â„‚.Mul â€¢ â„‚.Cod}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = Prâ‚ â€¢ â„‚.Mul}$
\item A term $\texttt{â„‚.Idâ‚ : â„‚.Mul â€¢ (â„‚.Idn Ã— ğŸ™\_(â„‚.Mor)) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Idâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Idn) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Ass : â„‚.Mul â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul)}$
\end{enumerate}
\end{definition}

Discounting those entries of the internal category structure which assume the existence of pullbacks, an internal category has 13 entries. Internal categories are often defined on categories with $\textit{all pullbacks}$, but here we take an approach in which $\texttt{InternalCategory}$ has type $\texttt{Cat â†’ Cat}$, so that it can be iterated. This entails separate entries assuming the existence of particular pullbacks.\\

%LEAN: definition of an internal category in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of an internal category in a pullback system
/-
structure internal_category (Î“ : Cat) where
  Obj : .Obj
  Mor : .Obj
  Dom : .Hom Mor Obj
  Cod : .Hom Mor Obj
  Idn : .Hom Obj Mor
  Fst : .Cmp Obj Mor Obj Idn Dom  = ğŸ™_(Î“.Obj) Obj
  Snd : .Cmp Obj Mor Obj Idn Cod = ğŸ™_(Î“.Obj) Obj
--  Cmp : D(Î“).Î“.PulObj ...
-- Idâ‚ : D(Î“).
-- Idâ‚‚ : D(Î“).
-- Ass : D(Î“).
-/

\end{minted}
\end{tcolorbox}
\end{center}

The internal functor structure combines with the internal category structure to give a category of internal categories in a pullback system.\\

%LEAN: definition of an internal functor in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of an internal functor in a pullback system
structure internal_functor (Î“ : pullback_system) (C : internal_category Î“) (D : internal_category Î“) where
  Obj : D(Î“).Hom C.Obj D.Obj
-- Mor : D(Î“).
-- Fst : D(Î“).
-- Snd : D(Î“).
-- Idn : D(Î“).
-- Cmp : D(Î“).

\end{minted}
\end{tcolorbox}
\end{center}


%LEAN: definition of the identity internal functor in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of the identity internal functor in a pullback system
def InternalCategoryIdn (Î“ : pullback_system) (C : internal_category Î“) : (internal_functor Î“ C C) := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: definition of the composition of internal functors in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- definition of the composition of internal functors in a pullback system
def InternalCategoryCmp (Î“ : pullback_system) (C : internal_category Î“) (D : internal_category Î“) (E : internal_category Î“) (F : internal_functor Î“ C D) (G : internal_functor Î“ D E) : (internal_functor Î“ C E) := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the first identity law for internal categories in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the the first identity law for internal categories in a pullback system
def InternalCategoryIdâ‚ (Î“ : pullback_system) (X : internal_category Î“) (Y : internal_category Î“) (f : internal_functor Î“ X Y) : InternalCategoryCmp Î“ X Y Y f (InternalCategoryIdn Î“ Y) = f := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the second identity law for internal categories  in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the second identity law for internal categories in a pullback system
def InternalCategoryIdâ‚‚ (Î“ : pullback_system) (X : internal_category Î“) (Y : internal_category Î“) (f : internal_functor Î“ X Y) : (InternalCategoryCmp Î“ X X Y (InternalCategoryIdn Î“ X) f = f) := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: proving the associativity law for internal categories in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- proving the associativity law for internal categories in a pullback system
def InternalCategoryAss (Î“ : pullback_system) (W : internal_category Î“) (X : internal_category Î“) (Y : internal_category Î“) (Z  : internal_category Î“) (f : internal_functor Î“ W X) (g : internal_functor Î“ X Y) (h : internal_functor Î“ Y Z) : InternalCategoryCmp Î“ W X Z f (InternalCategoryCmp Î“ X Y Z g h) = InternalCategoryCmp Î“ W Y Z (InternalCategoryCmp Î“ W X Y f g) h := sorry

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: defining the category of internal categories in a pullback system
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

/-
def InternalCategory (Î“ : pulback_system) : ğ‚ğšğ­.Obj := {Obj := internal_category Î“, Hom := internal_functor Î“, Idn := InternalCategoryIdn Î“, Cmp := InternalCategoryCmp Î“, Idâ‚ := InternalCategoryIdâ‚ Î“, Idâ‚‚ := InternalCategoryIdâ‚‚ Î“, Ass := InternalCategoryAss Î“}
-/

\end{minted}
\end{tcolorbox}
\end{center}

%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{Lean \thelcounter} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Blue,coltitle=black]
\begin{minted}[breaklines, escapeinside=||]{lean}

-- notation : 2000 "Cat_(" Î“ ")" => InternalCategory Î“

\end{minted}
\end{tcolorbox}
\end{center}


\section{\texttt{Internal Presheaves}}


Let $\mathbb{C}$ be a category, and let â„‚ : InternalCategory C be an internal category. A (left) internal presheaf consists of:

\begin{definition}[Internal Presheaf] 
\begin{enumerate}
\item An object $\texttt{â„‚.Mor : â„‚}$ 
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Idn : C.Hom â„‚.Obj â„‚.Mor}$
\item A term $\texttt{X : (pullback â„‚.Cod â„‚.Dom)}$
\item A term $\texttt{Xâ‚ : (pullback â„‚.Cod X.Prâ‚)}$
\item A term $\texttt{Xâ‚‚ : (pullback X.Prâ‚‚ â„‚.Dom)}$
\item A morphism $\texttt{â„‚.Mul : C.Hom X.Obj â„‚.Mor}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Mul =  Proj Ã— â„‚.Mul â€¢ â„‚.Cod}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = Prâ‚ â€¢ â„‚.Mul}$
\item A term $\texttt{â„‚.Idâ‚ : â„‚.Mul â€¢ (â„‚.Idn Ã— ğŸ™\_(â„‚.Mor)) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Idâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Idn) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Ass : â„‚.Mul â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul)}$
\end{enumerate}
\end{definition}

A (right) internal presheaf consists of:

\begin{definition}[Internal Presheaf] 
\begin{enumerate}
\item An object $\texttt{â„‚.Obj : â„‚}$
\item An object $\texttt{â„‚.Mor : â„‚}$ 
\item A morphism $\texttt{â„‚.Cod : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Dom : C.Hom â„‚.Mor â„‚.Obj}$
\item A morphism $\texttt{â„‚.Idn : C.Hom â„‚.Obj â„‚.Mor}$
\item A term $\texttt{X : (pullback â„‚.Cod â„‚.Dom)}$
\item A term $\texttt{Xâ‚ : (pullback â„‚.Cod X.Prâ‚)}$
\item A term $\texttt{Xâ‚‚ : (pullback X.Prâ‚‚ â„‚.Dom)}$
\item A morphism $\texttt{â„‚.Mul : C.Hom X.Obj â„‚.Mor}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ â„‚.Idn = ğŸ™\_(â„‚.Obj)}$
\item A term $\texttt{â„‚. : â„‚.Dom â€¢ â„‚.Mul =  Proj Ã— â„‚.Mul â€¢ â„‚.Cod}$
\item A term $\texttt{â„‚. : â„‚.Cod â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = Prâ‚ â€¢ â„‚.Mul}$
\item A term $\texttt{â„‚.Idâ‚ : â„‚.Mul â€¢ (â„‚.Idn Ã— ğŸ™\_(â„‚.Mor)) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Idâ‚‚ : â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Idn) â€¢ ??? = ğŸ™\_(â„‚.Mor)}$
\item A term $\texttt{â„‚.Ass : â„‚.Mul â€¢ (â„‚.Mul Ã— ğŸ™\_(â„‚.Mor)) = â„‚.Mul â€¢ (ğŸ™\_(â„‚.Mor) Ã— â„‚.Mul)}$
\end{enumerate}
\end{definition}

\iffalse
\begin{definition}[Internal Presheaf]
  \begin{enumerate}
  \item A class $\texttt{C.Obj}$ of objects
  \item For each pair of objects $\texttt{X,Y:Obj}$, a class 
  \[ \texttt{C.Hom X,Y} \] 
  whose elements are called maps or morphisms. 
  \item For each object $\texttt{X}$, a morphism 
  \[ \texttt{C.Idn X} \]
  \item For each triple of objects $\texttt{X, Y, Z : Obj}$, a function 
  \[ \texttt{C.Cmp X Y Z : (C.Hom X Y) â†’ (C.Hom Y Z) â†’ (C.Hom X Z)} \]
  \end{enumerate}
  such that, writing $\texttt{g âˆ˜\_(C) f}$ for $\texttt{C.Cmp X Y Z f g}$ and $\texttt{ğŸ™\_(X)}$ for $\texttt{C.Idn X}$,
  \begin{enumerate}
  \item $\texttt{âˆ€(X:Obj),âˆ€(Y:Obj),âˆ€(f:Hom X Y),}$
  \[\texttt{f âˆ˜\_(C) (Idn X)\ =\ f}\]
  \item $\texttt{âˆ€(X:Obj),âˆ€(Y:Obj),âˆ€(f:Hom X Y),}$
  \[\texttt{(Idn X) âˆ˜\_(C) f\ =\ f}\]
  \item $\texttt{âˆ€(W:Obj),âˆ€(X:Obj),âˆ€(Y:Obj),âˆ€(Z:Obj),}$ $\texttt{âˆ€(f:Hom W X),}$ $\texttt{âˆ€(g:Hom X Y),}$\\ $\texttt{âˆ€(h:Hom Y Z),}$
  \[\texttt{ f âˆ˜\_(C) (g âˆ˜\_(C) h) = (f âˆ˜\_(C) g) âˆ˜\_(C) h} \]
  \end{enumerate}
  \end{definition}
\fi



\section{The Pâƒ— and Oâƒ— Functors}

In this section we mention the internal category principal, which says that the pullback of any morphism with itself forms a component of an internal category in any category in which this pullback exists. In fact, the most general form of the theorem works for a noncommutative analogue of pullback.\\ 


\section{The pâƒ— and oâƒ— Functors}

Next we mention the internal presheaf principal, which says that the pullback of any morphism with another forms a component of an internal presheaf in any category with pullbacks. Just as is the case for the last theorem, the most general form of this idea works for non-commutative analogues of pullback, wheras the case of pullback gives an internal groupoid action.\\
\fi







\part{MODEL STRUCTURES}



\section{... âˆ-Grpd}

\begin{enumerate}
\item Î³\_(Cat) â†’\_(Cat) - : Cat.Hom Cat Cat is an endofunctor of Cat.
\item The colimit of Î¦â‚™ := (Î³\_(Cat) â†’\_(Cat) -)â¿ under the inclusions which use identity maps produces a category C, and the functor form C to the colimit of a natural transformation from Î¦â‚™ to itself is Î³\_(Cat) â†’\_(Cat) C. 
\item Call the new category â–¡ C
\item There is a functor from based objects in C to â–¡ C which is the composition of * C â†’ Maps C â†’ Maps â–¡ C â†’ â–¡ C
\item There is a functor from Maps C 
\item There is a functor from
\item There is a functor from 
\item The category of presheaves in âˆ-Grpd out of the infinite box (Nat â†’\_(Cat) Î³\_(Cat)) is
\item (Nat â†’\_(Cat) Î³\_(Cat) â†’\_(Cat) âˆ-Grpd...
\item 
\end{enumerate}



\section{... âˆ-Cat}

\begin{enumerate}
\item (Nat â†’\_(Cat) Î³\_(Cat)) â†’\_(Cat) âˆ-Cat
\end{enumerate}



\newpage
{
\Huge 
\begin{center}
\ \\
\ \\
\texttt{Bibliography}
\ \\
\ \\
\end{center}
\thispagestyle{empty}
}

\iffalse
Needs citation:

Pure Galois theory in categories (Janelidze) https://scholar.google.com/citations?view_op=view_citation&hl=en&user=fOYPVWwAAAAJ&citation_for_view=fOYPVWwAAAAJ:9yKSN-GCB0IC
\item Facets of descent I (Janelidze) https://scholar.google.com/citations?view_op=view_citation&hl=en&user=fOYPVWwAAAAJ&citation_for_view=fOYPVWwAAAAJ:2osOgNQ5qMEC
\item Internal object actions (Janelidze) https://scholar.google.com/citations?view_op=view_citation&hl=en&user=fOYPVWwAAAAJ&citation_for_view=fOYPVWwAAAAJ:zYLM7Y9cAGgC

\fi

\begin{enumerate}
\item Davis, James F., and Paul Kirk. Lecture notes in algebraic topology. Vol. 35. Providence: American Mathematical Society, 2001.
\item \iffalse \url{https://florisvandoorn.com/papers/dissertation.pdf} \fi
\item Galois theory and a general notion of central simple extension (Janelidze) \iffalse https://scholar.google.com/citations?view_op=view_citation&hl=en&user=fOYPVWwAAAAJ&citation_for_view=fOYPVWwAAAAJ:d1gkVwhDpl0C \fi
\item Borceux, F., and Janelidze, G. Galois Theories. Cambridge Studies in Advanced Mathematics, vol. 72. Cambridge University Press, Cambridge, 2001. ISBN 0-521-80309-8.
\item Tom Leinster, Higher Operads, Higher Categories, London Mathematical Society Lecture Note Series, vol. 298, Cambridge University Press, 2004.
\item Lurie, Jacob. Higher Topos Theory. Annals of Mathematics Studies, vol. 170. Princeton University Press, Princeton, NJ, 2009.
\item Leonardo de Moura and Jeremy Avigad, ``The Lean Theorem Prover," Journal of Formalized Reasoning, vol. 8, no. 1, pp. 1-37, 2015.
\item Leonardo de Moura and Soonho Kong, ``Lean Theorem Proving Tutorial," Proceedings of the 6th International Conference on Interactive Theorem Proving (ITP), Lecture Notes in Computer Science, vol. 9236, pp. 378-395, Springer, Berlin, 2015.
\item Jeremy Avigad, Leonardo de Moura, and Soonho Kong, ``Theorem Proving in Lean," Logical Methods in Computer Science, vol. 12, no. 4, pp. 1-43, 2016.
\item Daniel Selsam, Leonardo de Moura, David L. Dill, and David L. Vlah, ``Leonardo: A Solver for MIP and Mixed Integer Nonlinear Programming," Proceedings of the 33rd Conference on Neural Information Processing Systems (NeurIPS), pp. 493-504, 2019.
\item \url{https://www.uni-muenster.de/IVV5WS/WebHop/user/nikolaus/Papers/oo-bundles_general_theory.pdf}
\item \url{https://www.cse.chalmers.se/~coquand/cubicaltt.pdf}
\item \url{https://arxiv.org/pdf/1607.04156.pdf}
\item \url{https://carloangiuli.com}
\end{enumerate}

Further reading:

\begin{enumerate}
\item J. Beck, ``Distributive laws," in Seminar on Triples and Categorical Homology Theory, Springer-Verlag, 1969, pp. 119-140.
\item Saunders Mac Lane, "Categories for the Working Mathematician," Graduate Texts in Mathematics, vol. 5, Springer-Verlag, New York, 1971.
\item Samuel Eilenberg and Saunders Mac Lane, ``General Theory of Natural Equivalences," Transactions of the American Mathematical Society, vol. 58, no. 2, pp. 231-294, 1945.
\item Daniel M. Kan, ``Adjoint Functors," Transactions of the American Mathematical Society, vol. 87, no. 2, pp. 294-329, 1958.
\item Chris Heunen, Jamie Vicary, and Stefan Wolf, ``Categories for Quantum Theory: An Introduction," Oxford Graduate Texts, Oxford University Press, Oxford, 2018.
\item S. Eilenberg and J. C. Moore, ``Adjoint Functors and Triples," Proceedings of the Conference on Categorical Algebra, La Jolla, California, 1965, pp. 89-106.
\item Daniel M. Kan, ``On Adjoints to Functors" (1958): In this paper, Kan further explored the theory of adjoint functors, focusing on the existence and uniqueness of adjoints. His work provided important insights into the fundamental aspects of adjoint functors and their role in category theory.
\item \href{https://mathematicswithoutapologies.wordpress.com/2015/05/13/univalent-foundations-no-comment/}{A comment thread concerning Jacob Lurie's breakthrough prize and different approaches to homotopy on the computer}
\item Arlin, Kevin David. "2-categorical Brown representability and the relation between derivators and infinity-categories." Doctoral dissertation, University of California, Los Angeles, 2020.
\item 
\end{enumerate}

Some lectures, videos, and Stackexchange questions:

\begin{enumerate}
\item \url{https://www.youtube.com/watch?v=Ob9tOgWumPI}
\item \url{https://www.youtube.com/watch?v=xYenPIeX6MY}
\item \url{https://mathoverflow.net/questions/5901/do-the-signs-in-puppe-sequences-matter}
\end{enumerate}

\iffalse
Maintainers:

For a list containing more detailed information, see https://leanprover-community.github.io/teams/maintainers.html

https://www.youtube.com/watch?v=6FLmQwhQlwA
https://www.youtube.com/watch?v=kjBDkH10OnQ
https://www.birs.ca/events/2023/5-day-workshops/23w5124/videos/watch/202305241110-Riou.html
https://github.com/ADedecker/gauss
https://github.com/ADedecker/amenable

\fi


Ideas for future applications:

\begin{enumerate}
\item \url{https://arxiv.org/pdf/2206.13563.pdf}
\end{enumerate}





\newpage 
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
%LEAN: 
\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{About the Author} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Yellow,coltitle=black]
Dean Young is a master's student at New York University, where he studies mathematics. \\
\begin{center}
\includegraphics[width=7.5cm,height=5cm]{about.jpg}
\end{center}
\end{tcolorbox}
\end{center}

\begin{center}
\begin{tcolorbox}[width=5in,colback={white},title={\begin{center}\texttt{About the Author} \addtocounter{lcounter}{1}  \end{center}},colbacktitle=Yellow,coltitle=black]
Jiazhen Xia is a graduate student at Zhejiang University, where he studies computer science. \\
\begin{center}
\includegraphics[width=7.5cm]{about2.jpg}
\end{center}
\end{tcolorbox}
\end{center}
\newpage
\ \\
\thispagestyle{empty}






\end{document}







































